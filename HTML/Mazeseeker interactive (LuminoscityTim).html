<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <title>Mazeseeker — Keep Talking and Nobody Explodes Module</title>
    <link rel="stylesheet" type="text/css" href="css/font.css">
    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/main.css">
    <script src="js/ktane-utils.js"></script>
    <script src="js/jquery.3.1.1.min.js"></script>
    <script src="js/Utilities/svg-utils.js"></script>
    <script src="js/Utilities/math-utils.js"></script>
    <script src="js/Utilities/ui-utils.js"></script>
    <script>
    $(function() {
        var selected;
        var selectedTool;
        let maze = $("svg.themaze");
        let body = $("body");
        let sizeNumber = $(".sizeNumber");
        let currX = 0;
        let currY = 0;
        let mazeSize = 6;
        let startPos = 0;
        let pressing = false;
        let movementList = [];
        let answerList = [];
        let generating = false;
        let saveStates = [];
        let currentState = 0;
        let offsets = [mazeSize, 1, -mazeSize, -1];
        let mazeWalls;
        let shownMazeWalls = Array(mazeSize * mazeSize).fill('');
        const SQUARE_WIDTH = 90;
        const MOV_RANGE = 9;
        const MIN_SIZE = 3;
        const MAX_SIZE = 10;
        const MODE_READ = 0;
        const MODE_SOLVE = 1;
        const MODE_EXPERT= 2;
        const MODE_PLAY = 3;
        const MOV_FREE = 0;
        const MOV_ENFORCE = 1;
        const NUM_DIR = 4;
        let gameGrid = Array(MAX_SIZE).fill().map(()=>Array(MAX_SIZE).fill(-1));
        let origGameGrid = Array(MAX_SIZE).fill().map(()=>Array(MAX_SIZE).fill(-1));

        const fulldir = {
            Up: [0, -1],
            Left: [-1, 0],
            Down: [0, 1],
            Right: [1, 0],
            w: [0, -1],
            a: [-1, 0],
            s: [0, 1],
            d: [1, 0],
            0: [0, -1],
            1: [-1, 0],
            2: [0, 1],
            3: [1, 0]
        }
        const directions = {
            Up: [0, 0],
            Left: [0, 0],
            Down: [0, 1],
            Right: [1, 0],
            w: [0, 0],
            a: [0, 0],
            s: [0, 1],
            d: [1, 0],
            0: [0, 0],
            1: [0, 0],
            2: [0, 1],
            3: [1, 0]
        };
        const dirIndex = {
            Up: 0,
            Left: 1,
            Down: 2,
            Right: 3,
            w: 0,
            a: 1,
            s: 2,
            d: 3,
        };
        const walldir = {
            Up: "h",
            Left: "v",
            Down: "h",
            Right: "v",
            w: "h",
            a: "v",
            s: "h",
            d: "v"
        }
        const dirLetter = {
            Up: "U",
            Left: "L",
            Down: "D",
            Right: "R",
            w: "U",
            a: "L",
            s: "D",
            d: "R",
            0: "U",
            1: "L",
            2: "D",
            3: "R",
            4: ['U','L','D','R']
        }

        const viewboxSize = {
            3:"0 0 350 350",
            4:"0 0 450 450",
            5:"0 0 550 550",
            6:"0 0 650 650",
            7:"0 0 750 750",
            8:"0 0 850 850",
            9:"0 0 950 950",
            10:"-7 0 1057 1050",
        }

        function selectNone() {
            selectedTool = null;
            updateSelection();
        }

        function updateSelection() {
            $(".selected").removeClass("selected");
            if (selected && selected.length > 0) {
                selected.addClass("selected");
            }
        }

        function getXY(pos) {
            return [pos % mazeSize, Math.floor(pos / mazeSize)];
        } 

        function resetPos() {
            $(".solved-text").addClass("invis");
            [currX, currY] = getXY(startPos);
            selected = $(`.square.x${currX+1}.y${currY+1}`);
            updateSelection();
            movementList = [];
            $(".path .str").text("");
        }

        //This function is taken from the module source code
        function generate() {
            generating = true;
            let mList = [];
            let movementAmount = Math.floor(Math.random() * MOV_RANGE) + mazeSize;

            let startingNode = Math.floor(Math.random() * mazeSize * mazeSize);
            let currentNode = startingNode;
            let visitOrder = [];
            let visited = Array(mazeSize * mazeSize).fill(false);
            mazeWalls = Array(mazeSize * mazeSize).fill('');
            let done = false;
            do
            {
                visitOrder.push(currentNode);
                visited[currentNode] = true;
                while (getAdjacents(currentNode).every(x => visited[x]) && !done)
                    if (visitOrder.length > 0)
                        currentNode = visitOrder.pop();
                    else {
                        done = true;
                        break;
                    }
                if (done) break;
                let chosenDestination = getAdjacents(currentNode).filter(x => !visited[x]).sample();
                let dir = offsets.indexOf(currentNode - chosenDestination);
                mazeWalls[currentNode] += dirLetter[dir];
                mazeWalls[chosenDestination] += dirLetter[(dir + 2) % NUM_DIR];
                currentNode = chosenDestination;
            } while (currentNode != startingNode);

            let endPos = Math.floor(Math.random() * mazeSize * mazeSize);
            let cornerPos = Math.floor(Math.random() * mazeSize * mazeSize);
            let sol;
            let min = Math.pow(mazeSize / 2, 2);
            do {
                startPos = Math.floor(Math.random() * mazeSize * mazeSize);
                sol = FindPath(startPos, endPos);
            } while (sol.length < min);
            answerList = sol.split(/(?!^)/);

            [currX, currY] = getXY(startPos);
            selected = $(`.square.x${currX+1}.y${currY+1}`);
            updateSelection();
            $(".square").removeClass("goal start first");
            let [gx,gy] = getXY(endPos);
            let [cx,cy] = getXY(cornerPos);
            $(`.square.x${gx+1}.y${gy+1}`).addClass("goal");
            selected.addClass("start");

            for (let y = 0; y < mazeSize; y++)
            for (let x = 0; x < mazeSize; x++) {
                let pos = y * mazeSize + x;
                gameGrid[x][y] = 4 - mazeWalls[pos].length;
            }
            updateGrid();
            shiftMaze(cx, cy);
            $(`.square.x${cx+1}.y${cy+1}`).addClass("first");
            selected = $('.square.selected');
            console.log(mazeWalls.map(w => dirLetter[4].filter(l => !w.includes(l)).join('')));
            
            $("path.wall").removeClass("solid");
            updateSize();

            $(".path .str").html("");
            $(".solution .str").html(answerList.join(" "));
            $(".solved-text").addClass("invis");
            generating = false;
        }

        function getAdjacents(pos) {
            let adjacents = [];
            if (pos % mazeSize != 0) adjacents.push(pos - 1);
            if (pos % mazeSize != mazeSize - 1) adjacents.push(pos + 1);
            if (pos > mazeSize - 1) adjacents.push(pos - mazeSize);
            if (pos < mazeSize * (mazeSize - 1)) adjacents.push(pos + mazeSize);
            return adjacents;
        }

        Array.prototype.sample = function(){
            return this[Math.floor(Math.random()*this.length)];
        }

        class Movement {
            constructor(s, e, d) {
                this.start = s;
                this.end = e;
                this.direction = "ULDR"[d];
            }
        }
        Movement.prototype.toString = function() {
            return `(${this.start}, ${this.end}, ${this.direction})`;
        }

        function FindPath(start, end) {
            if (start == end)
                return '';
            let q = [];
            let allMoves = [];
            q.push(start);
            while (q.length > 0) {
                let subject = q.shift();
                for (let i = 0; i < NUM_DIR; i++) {
                    if (mazeWalls[subject].includes(dirLetter[i]) && !allMoves.some(x => x.start == subject - offsets[i])) {
                        q.push(subject - offsets[i]);
                        allMoves.push(new Movement(subject, subject - offsets[i], i));
                    }
                }
                if (subject == end) break;
            }
            if (allMoves.length != 0) {
                let lastMove = allMoves.find(x => x.end == end);
                let path = [lastMove];
                while (lastMove.start != start) {
                    lastMove = allMoves.find(x => x.end == lastMove.start);
                    path.push(lastMove);
                }
                path.reverse();
                let solution = '';
                for (let i = 0; i < path.length; i++)
                    solution += path[i].direction;
                return solution;
            }
            else return '';
        }

        function attemptMove(pos) {
            let cur = currY * mazeSize + currX;
            let offset = cur - pos;
            if (!pressing && getAdjacents(cur).includes(pos)) {
                let dirPressed = dirLetter[offsets.indexOf(offset)];
                if (!(shownMazeWalls[cur].includes(dirPressed))) {
                    pressing = true;
                    return true;
                }
                else return false;
            }
            return false;
        }

        const saved_classes = 'selected start first goal';
        function shiftMaze(shiftX, shiftY) {
            let saved = Array(mazeSize).fill().map(()=>Array(mazeSize).fill(0));
            let savedClass = Array(mazeSize).fill().map(()=>Array(mazeSize).fill(""));
            for (let y = 0; y < mazeSize; y++)
                for (let x = 0; x < mazeSize; x++) {
                    saved[x][y] = gameGrid[x][y];
                    savedClass[x][y] = $(`.square.x${x+1}.y${y+1}`).attr("class")
                        .split(" ").filter(s => saved_classes.includes(s)).join(" ");
                }

            for (let y = 0; y < mazeSize; y++)
                for (let x = 0; x < mazeSize; x++) {
                    gameGrid[x][y] = saved[UMod(x-shiftX, mazeSize)][UMod(y-shiftY, mazeSize)];
                    let elem = $(`.square.x${x+1}.y${y+1}`);
                    elem.removeClass(saved_classes);
                    elem.addClass(savedClass[UMod(x-shiftX, mazeSize)][UMod(y-shiftY, mazeSize)]);
                }
            selected = $(".square.selected");
            updateGrid();
        }

        function arrowPressed(direction, type, fdir, dirIdx) {
            if ([MODE_READ,MODE_EXPERT].includes(mode())) {
                if (shift()) {
                    shiftMaze(fdir[0], fdir[1]);
                    return;
                }
                let x = currX + direction[0];
                let y = currY + direction[1];
                let p = currY * mazeSize + currX;
                let ox = currX + fdir[0];
                let oy = currY + fdir[1];
                let wallv = `v${letter(x-1)}${letter(x)}${y+1}`;
                let wallh = `h${y}${y+1}${letter(x)}`;
                let wall = null;
                if (type == "v" && x > 0 && x < mazeSize && y >= 0 && y < mazeSize)
                    wall = $(`svg .wall.${wallv}`);
                else if (type == "h" && x >= 0 && x < mazeSize && y > 0 && y < mazeSize)
                    wall = $(`svg .wall.${wallh}`);

                if (wall != null) {
                    wall.toggleClass("solid");
                    if (wall.hasClass("solid")) {
                        if (!shownMazeWalls[p].includes(dirLetter[dirIdx])) shownMazeWalls[p] += dirLetter[dirIdx];
                        if (ox >= 0 && ox < mazeSize && oy >= 0 && oy < mazeSize) {
                            p = oy * mazeSize + ox;
                            let idx = (dirIdx + 2) % NUM_DIR;
                            if (!shownMazeWalls[p].includes(dirLetter[idx])) shownMazeWalls[p] += dirLetter[idx];
                        }
                    }
                    else {
                        shownMazeWalls[p] = shownMazeWalls[p].replaceAll(dirLetter[dirIdx], '');
                        if (ox >= 0 && ox < mazeSize && oy >= 0 && oy < mazeSize) {
                            p = oy * mazeSize + ox;
                            shownMazeWalls[p] = shownMazeWalls[p].replaceAll(dirLetter[(dirIdx + 2) % NUM_DIR], '');
                        }
                    }
                }
            }
            else {
                let x = currX + fdir[0];
                let y = currY + fdir[1];
                if (x >= 0 && x < mazeSize && y >= 0 && y < mazeSize)
                    $(`.square.x${x+1}.y${y+1}`).click();
            }
        }

        let down = false;
        $(document).click(function() {
            selectNone();
        }).keydown(function(event) {
            if (down)
                return false;
            down = true;
            let k = event.key.toLowerCase();
            if (event.key.startsWith("Arrow")) {
                let direction = directions[event.key.substring(5)];
                let wallt = walldir[event.key.substring(5)];
                let fdir = fulldir[event.key.substring(5)];
                let dirIdx = dirIndex[event.key.substring(5)];
                arrowPressed(direction, wallt, fdir, dirIdx);
                event.preventDefault();
            } else if (NoSpecialKeys(event) && (k == "w" || k == "a" || k == "s" || k == "d")) {
                let direction = directions[k];
                let wallt = walldir[k];
                let fdir = fulldir[k];
                let dirIdx = dirIndex[k];
                arrowPressed(direction, wallt, fdir, dirIdx);
            }
            else if (k == "-")
                sizeDec();
            else if (k == "=" || k == "+")
                sizeInc();
            else if (NoSpecialKeys(event)) {
                let n = parseInt(event.key);
                if (k == " " || k == "enter" || (n >= 0 && n <= 3 && !event.altKey)) {
                    if (k == " " || k == "enter") {
                        n = -1;
                        event.preventDefault();
                    }
                    if (selected && selected.hasClass("square")) {
                        if (mode() == MODE_READ) {
                            gameGrid[currX][currY] = n;
                            playZeroOneSound(n);
                            updateGrid();
                        }
                        if (currX == mazeSize - 1)
                            currY = (currY + 1) % mazeSize;
                        currX = (currX + 1) % mazeSize;
                        selected = $(`.square.x${currX+1}.y${currY+1}`);
                        updateSelection();
                    }
                }
            }
 
            down = false;
        });

        function removeSizeClass(elem) {
            let classes = elem[0].classList;
            let cl = Array.from(classes).find(c => c.startsWith('size')) ?? '';
            elem.removeClass(cl);
        }

        function updateSize(increase = false) {
            offsets[0] = mazeSize;
            offsets[2] = -mazeSize;
            sizeNumber.text(mazeSize);
            maze.attr('viewBox', viewboxSize[mazeSize]);
            removeSizeClass(maze);
            removeSizeClass(body);
            maze.addClass(`size${mazeSize}`);
            body.addClass(`size${mazeSize}`);
            shownMazeWalls = Array(mazeSize * mazeSize).fill('');
            for (let x = 0; x <= mazeSize; x++) {
                if (x < mazeSize) {
                    $(`path.wall.v${letter(-1)}${letter(0)}${x+1}`).addClass("solid");
                    $(`path.wall.v${letter(mazeSize-1)}${letter(mazeSize)}${x+1}`).addClass("solid");
                    $(`path.wall.h${0}${1}${letter(x)}`).addClass("solid");
                    $(`path.wall.h${mazeSize}${mazeSize+1}${letter(x)}`).addClass("solid");
                }
                $(`path.wall.v${letter(x-1)}${letter(x)}${mazeSize+1}`).removeClass("solid");
                $(`path.wall.h${x}${x+1}${letter(mazeSize)}`).removeClass("solid");
                if (increase) {
                    $(`path.wall.v${letter(mazeSize-2)}${letter(mazeSize-1)}${x+1}`).removeClass("solid");
                    $(`path.wall.h${mazeSize-1}${mazeSize}${letter(x)}`).removeClass("solid");
                }
            }
        }

        function sizeDec() {
            mazeSize = Math.max(MIN_SIZE, mazeSize - 1);
            updateSize();
        }
        function sizeInc() {
            mazeSize = Math.min(MAX_SIZE, mazeSize + 1);
            updateSize(true);
        }
        $(".sizetext.minus").click(function() {
            sizeDec();
        });
        $(".sizetext.plus").click(function() {
            sizeInc();
        });

        function updateGrid() {
            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    let n = gameGrid[x][y];
                    let elem = $(`.square.x${x+1}.y${y+1} text`);
                    elem.html(n < 0 ? "" : n);
                }
            }
        }

        function mode() {
            if ($("button.expert-play").hasClass("play")) {
                if ($("button.read-solve").hasClass("solve"))
                    return MODE_PLAY;
                else
                    return MODE_EXPERT;
            }
            else if ($("button.read-solve").hasClass("solve"))
                return MODE_SOLVE;
            else
                return MODE_READ;
        }
        function movement() {
            if ($("button.movement").hasClass("free"))
                return MOV_FREE;
            else
                return MOV_ENFORCE;
        }
        function shift() {
            return document.querySelector("#shift-maze").checked;
        }

        function letter(i) {
            return i < 0 ? String.fromCharCode(123 + i) : String.fromCharCode(65 + i);
        }
        function toNum(x) {
            let code = x.toUpperCase().charCodeAt(0)
            if (code > 64 && code < 91)
                return code - 64;
            return 0;
        }

        for (let x = 0; x <= MAX_SIZE; x++) {
            if (x > 0) {
                let header1 = MakeSvgElem("text", {
                    x:15, y:(x*100 + 10), "text-anchor":"middle", "font-size":40, stroke:"transparent", class:"grid-header"
                }, x);
                let header2 = MakeSvgElem("text", {
                    x:(x*100 - 2), y:30, "text-anchor":"middle", "font-size":40, stroke:"transparent", class:"grid-header"
                }, letter(x-1));
                maze.append(header1);
                maze.append(header2);
            }
            for (let y = 0; y <= MAX_SIZE; y++) {
                if (x <= MAX_SIZE && y < MAX_SIZE) {
                    let vwall = MakeSvgElem("path", {
                        d:`M${x*100 + 45} ${y*100 + 45}v100`, fill:"none", class:`wall v${letter(x-1)}${letter(x)}${y+1}`, stroke:"#FF0000BB"
                    });
                    maze.append(vwall);
                }
                if (y <= MAX_SIZE && x < MAX_SIZE) {
                    let hwall = MakeSvgElem("path", {
                        d:`M${x*100 + 45} ${y*100 + 45}h100`, fill:"none", class:`wall h${y}${y+1}${letter(x)}`, stroke:"#FF0000BB"
                    });
                    maze.append(hwall);
                }
                if (x == 0 || y == 0) continue;

                let square = MakeSvgElem("g", { class: `square x${x} y${y}` });
                let text = MakeSvgElem("text", {
                    x:(x*100 - 5), y:(y*100 + 6), "font-size":34, fill:"#DDD", "text-anchor":"middle"
                });
                let netsquare = MakeSvgElem("rect", {
                    x:(x*100 - 50), y:(y*100 - 50), width:SQUARE_WIDTH, height:SQUARE_WIDTH, class:"netsquare black", stroke:"none"
                });
                square.appendChild(netsquare);
                square.appendChild(text);
                maze.append(square);
                $(square).click(function(event) {
                    down = false;
                    let txt = $(this).find("text");
                    let pos = (y-1) * mazeSize + x-1;
                    if ([MODE_PLAY,MODE_SOLVE].includes(mode()) && movement() == MOV_ENFORCE && !attemptMove(pos)) {
                        pressing = false;
                        return false;
                    }
                    if (selectedTool == "goal") {
                        $(".square.goal").removeClass("goal");
                        $(this).addClass("goal");
                        return true;
                    } else if (selectedTool == "start") {
                        $(".square.start").removeClass("start");
                        $(this).addClass("start");
                        startPos = pos;
                        return true;
                    } else if (selectedTool == "first") {
                        $(".square.first").removeClass("first");
                        $(this).addClass("first");
                        return true;
                    } else if ([MODE_READ].includes(mode()) && shift()) {
                        gameGrid[x-1][y-1] = ((gameGrid[x-1][y-1] + 2) % 5) - 1;
                        origGameGrid[x-1][y-1] = gameGrid[x-1][y-1];
                        playZeroOneSound(gameGrid[x-1][y-1]);
                        updateGrid();
                    }

                    if ([MODE_PLAY,MODE_SOLVE].includes(mode())) {
                        let dist = Math.abs(x-1 - currX) + Math.abs(y-1 - currY);
                        if (movement() == MOV_ENFORCE && dist == 1) {
                            let cur = currY * mazeSize + currX;
                            let offset = cur - pos;
                            if (getAdjacents(cur).includes(pos)) {
                                movementList.push(dirLetter[offsets.indexOf(offset)]);
                                $(".path .str").text(movementList.join(" "));
                            }
                        }
                        if (mode() == MODE_PLAY && $(this).hasClass("goal")) {
                            if ($("button.sound").hasClass("play"))
                                audioSolve[0].play();
                            $(".solved-text").removeClass("invis");
                        }
                        else {
                            if ($("button.sound").hasClass("play")) {
                                let aud = audioStep[0].cloneNode();
                                aud.volume = 0.3;
                                aud.play();
                            }
                            $(".solved-text").addClass("invis");
                        }
                    }

                    selected = $(this);
                    updateSelection();
                    currX = x-1;
                    currY = y-1;
                    pressing = false;
                });
                if (x == 1 && y == 1) {
                    selected = $(square);
                    $(square).addClass("selected");
                }
            }
        }
        updateSize();

        $(".arrows button").click(function(event) {
            let q = this.className.split("-")[1];
            let direction = directions[q];
            let type = walldir[q];
            let fdir = fulldir[q];
            let dirIdx = dirIndex[q];
            arrowPressed(direction, type, fdir, dirIdx);
            event.preventDefault();
            event.stopPropagation();
        });
        let othertools = $(".othertools");
        $("<div>").addClass("tool starttool").text("Start").appendTo(othertools).click(function(event) {
            $(".tool").removeClass("selected");
            $(this).addClass("selected");
            selectedTool = "start";
            event.preventDefault();
            event.stopPropagation();
        });
        $("<div>").addClass("tool goaltool").text("Goal").appendTo(othertools).click(function(event) {
            $(".tool").removeClass("selected");
            $(this).addClass("selected");
            selectedTool = "goal";
            event.preventDefault();
            event.stopPropagation();
        });
        $("<div>").addClass("tool firsttool").text("Corner").appendTo(othertools).click(function(event) {
            $(".tool").removeClass("selected");
            $(this).addClass("selected");
            selectedTool = "first";
            event.preventDefault();
            event.stopPropagation();
        });
        $("<div>").addClass("tool reset-grid").text("↻").appendTo(othertools).click(function(event) {
            resetPos();
            event.preventDefault();
            event.stopPropagation();
        });

        let tools = $(".tools");
        let audio0 = $("<audio>")
            .attr("src", "audio/Not The Bulb/TapCode.wav")
            .appendTo(tools);
        let audio1 = $("<audio>")
            .attr("src", "audio/Not The Bulb/NonoClick.wav")
            .appendTo(tools);
        let audioStep = $("<audio>")
            .attr("src", "audio/Pathfinder/footstep.mp3")
            .appendTo(tools);
        let audioSolve = $("<audio>")
            .attr("src", "audio/Module Listening/Creation - Solve.wav")
            .prop("volume", 0.4)
            .appendTo(tools);
        function playZeroOneSound(n) {
            if ($("button.sound").hasClass("play") && n > -1) {
                let aud = UMod(n, 2) == 0 ? audio0[0].cloneNode() : audio1[0].cloneNode();
                aud.volume = 0.3;
                aud.play();
            }
        }

        $("<h3>").addClass("solved-text invis centered").text("Solved!").prependTo(tools);

        $("<button>").addClass("read-solve").appendTo(tools).click(function() {
            $(this).toggleClass("solve");
            $("body").toggleClass("solve", $(this).hasClass("solve"));

            if ([MODE_PLAY,MODE_SOLVE].includes(mode())) {
                resetPos();
            }
            // console.log(shownMazeWalls);
        });
        $("<button>").addClass("movement").appendTo(tools).click(function() {
            $(this).toggleClass("free");
            $("body").toggleClass("free", $(this).hasClass("free"));
        });
        $("<button>").addClass("sound play").appendTo(tools).click(function() {
            $(this).toggleClass("play");
        });
        $("<button>").addClass("expert-play").appendTo(tools).click(function() {
            if (generating)
                return false;
            $(this).toggleClass("play");
            $("body").toggleClass("play", $(this).hasClass("play"));
            if ([MODE_PLAY,MODE_EXPERT].includes(mode())) {
                generate();
            }
            else resetPos();
        });
        $("<button>").addClass("show-sol").appendTo(tools).click(function() {
            $(this).toggleClass("show");
            $("body").toggleClass("solution-shown", $(this).hasClass("show"));
        });

        function wallToggle(x, y, type, state) {
            let wallv = `v${letter(x-1)}${letter(x)}${y+1}`;
            let wallh = `h${y}${y+1}${letter(x)}`;
            if (type == "v" && x >= 0 && x <= mazeSize && y >= 0 && y <= mazeSize) {
                $(`svg .wall.${wallv}`).toggleClass("solid", state);
            }
            else if (type == "h" && x >= 0 && x <= mazeSize && y >= 0 && y <= mazeSize) {
                $(`svg .wall.${wallh}`).toggleClass("solid", state);
            }
        }
        $(".radar").click(function() {
            if ([MODE_READ,MODE_SOLVE].includes(mode())) return false;
            if (selected && selected.hasClass("square")) {
                for (let i = 0; i < NUM_DIR; i++) {
                    wallToggle(currX + directions[i][0], currY + directions[i][1], i % 2 == 0 ? "h":"v", false);
                    let pos = currY * mazeSize + currX;
                    shownMazeWalls[pos] = shownMazeWalls[pos].replaceAll(dirLetter[i], '');
                    let ox = currX + fulldir[i][0];
                    let oy = currY + fulldir[i][1];
                    if (ox >= 0 && ox < mazeSize && oy >= 0 && oy < mazeSize) {
                        let p = oy * mazeSize + ox;
                        let idx = (i + 2) % NUM_DIR;
                        shownMazeWalls[p] = shownMazeWalls[p].replaceAll(dirLetter[idx], '');
                    }

                    if (!mazeWalls[pos].includes(dirLetter[i])) {
                        wallToggle(currX + directions[i][0], currY + directions[i][1], i % 2 == 0 ? "h":"v", true);
                        if (!shownMazeWalls[pos].includes(dirLetter[i])) shownMazeWalls[pos] += dirLetter[i];
                        ox = currX + fulldir[i][0];
                        oy = currY + fulldir[i][1];
                        if (ox >= 0 && ox < mazeSize && oy >= 0 && oy < mazeSize) {
                            let p = oy * mazeSize + ox;
                            let idx = (i + 2) % NUM_DIR;
                            if (!shownMazeWalls[p].includes(dirLetter[idx])) shownMazeWalls[p] += dirLetter[idx];
                        }
                    }
                }
            }
        });
        $(".reset-walls").click(function() {
            $("path.wall").removeClass("solid");
            updateSize();
        });
        $(".reset-saves").click(function() {
            saveStates.forEach(x => x.remove());
            saveStates = [];
            currentState = 0;
        });
        $(".reset-all").click(function() {
            $(".square").removeClass("goal start first");
            $(".prime-box").removeClass("highlighted");
            $("path.wall").removeClass("solid");
            $(".solved-text").addClass("invis");
            $("button.movement").removeClass("free");
            $("body").removeClass("free solution-shown solve play");
            $("button.sound").addClass("play");
            $("button.expert-play").removeClass("play");
            $("button.show-sol").removeClass("show");
            $("button.read-solve").removeClass("solve");
            startPos = 0;
            resetPos();

            saveStates.forEach(x => x.remove());
            saveStates = [];
            currentState = 0;
            mazeSize = 6;
            shownMazeWalls = Array(mazeSize * mazeSize).fill('');
            updateSize();
        });

        function removeFutureSaves() {
            if (currentState < saveStates.length - 1) {
                for (let i = currentState + 1; i < saveStates.length; i++) {
                    saveStates[i].remove();
                }
                saveStates.splice(currentState + 1, saveStates.length - currentState);
            }
        }

        $("button.save").click(function() {
            removeFutureSaves();

            let saveStateClass = Array.from($(".prime-box, .square, path.wall, .solved-text, .tools button")).map(x => $(x)).map(x => x.attr("class") || "");
            let saveStateBody = Array.from($("body")).map(x => $(x)).map(x => x.attr("class") || "");
            console.log(saveStates);
            let stateNumber = saveStates.length;
            currentState = stateNumber;

            let s_offsets = [];
            let s_mazeWalls = [];
            let s_shownMazeWalls = [];
            Object.assign(s_offsets, offsets);
            Object.assign(s_mazeWalls, mazeWalls);
            Object.assign(s_shownMazeWalls, shownMazeWalls);
            let s_answerList = [];
            let s_movementList = [];
            Object.assign(s_movementList, movementList);
            Object.assign(s_answerList, answerList);
            let s_gameGrid = Array(MAX_SIZE).fill().map(()=>Array(MAX_SIZE).fill(-1));
            let s_origGameGrid = Array(MAX_SIZE).fill().map(()=>Array(MAX_SIZE).fill(-1));
            for (let y = 0; y < mazeSize; y++)
                for (let x = 0; x < mazeSize; x++) {
                    s_gameGrid[x][y] = gameGrid[x][y];
                    s_origGameGrid[x][y] = origGameGrid[x][y];
                }
            let s_selected = selected;
            let s_selectedTool = selectedTool;
            let s_size = mazeSize;
            let s_currX = currX;
            let s_currY = currY;
            let s_pressing = pressing;
            let s_startPos = startPos;

            let button = $("<button>").text(stateNumber + 1).click(function() {
                mazeSize = s_size;
                updateSize();

                $(".prime-box, .square, path.wall, .solved-text, .tools button").each((i, x) => $(x).attr("class", saveStateClass[i]));
                $("body").each((i, x) => $(x).attr("class", saveStateBody[i]));
                mazeWalls = Array(s_mazeWalls.length);
                shownMazeWalls = Array(s_shownMazeWalls.length);
                Object.assign(mazeWalls, s_mazeWalls);
                Object.assign(shownMazeWalls, s_shownMazeWalls);
                Object.assign(offsets, s_offsets);
                movementList = Array(s_movementList.length);
                answerList = Array(s_answerList.length);
                Object.assign(movementList, s_movementList);
                Object.assign(answerList, s_answerList);
                $(".path .str").text(movementList.join(" "));
                $(".solution .str").text(answerList.join(" "));
                for (let y = 0; y < mazeSize; y++) {
                    for (let x = 0; x < mazeSize; x++) {
                        gameGrid[x][y] = s_gameGrid[x][y];
                        origGameGrid[x][y] = s_origGameGrid[x][y];
                    }
                }
                updateGrid();

                currentState = stateNumber;
                selected = s_selected;
                selectedTool = s_selectedTool;
                currX = s_currX;
                currY = s_currY;
                startPos = s_startPos;
                pressing = s_pressing;
            }).addClass("flash").appendTo(".saves");
            setTimeout(() => {
                button.removeClass("flash");
            }, 100);

            saveStates.push(button);
        });
    });
    </script>
    <style>
        table.mazediagram {
            width: 12em;
            height: 12em;
            position: relative;
            font-size: 13px;
            z-index: 1;
            border-collapse: collapse;
            margin-bottom: 1em;
        }
        .mazediagram :is(td,th) { padding: .2em .6em 0; }
        p {
            font-size: 14px;
        }
        .dark th, th { border: none; }
        th.right { border-right: solid; }
        th.left { border-left: solid; }
        th.up { border-top: solid; }
        th.down { border-bottom: solid; }
        table {
            margin: 1em auto;
        }

        .hstack {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
        }
        .hstack.gap { gap: 10px; }
        .vstack {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .wrap {
            flex-wrap: wrap;
        }
        .hstack.just-left {
            justify-content: left;
        }
        .vstack.just-left {
            align-items: start;
        }
        
        .othertools {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .toolset { gap: 10px; }
        .toolset1 { margin: 5px; }
        .tool {
            width: 70px;
            height: 50px;
            float: left;
            font-size: 18px;
            user-select: none;
            text-align: center;
            border: black 1px solid;
            padding-top: 4px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            cursor: pointer;
            box-sizing: border-box;
        }
        .goaltool, .starttool, .firsttool { height: 35px; }
        .starttool.selected { border: red 2px dashed; }
        .goaltool.selected { border: #0F0 2px dashed; }
        .firsttool.selected { border: #33F 2px dashed; }
        .reset-grid { font-size: 35px; }

        .dark .tool:not(.selected) { border-color: #DDD; }
        .tools {
            width: 115px;
        }
        .tools button {
            margin: 10px;
        }
        .solved-text {
            color: #0C0;
            transition: color 0.5s;
            user-select: none;
        }
        .invis { color: transparent; }

        svg.themaze path.wall {
            stroke: transparent;
            stroke-linecap: round;
            stroke-width: 9;
        }
        svg.themaze path.wall.solid {
            stroke: #F44;
        }
        svg .square text {
            font-family: 'Roboto Mono';
        }
        svg.themaze text { user-select: none; }
        .dark svg .grid-header { fill: #DDD; }

        .solution, .path {
            font-size: 20px;
            transition: 0.5s;
        }
        .path span:not(.str), .solution span:not(.str) {
            display: inline-block;
            min-width: 108px;
        }
        body:not(.solution-shown) .path,
        body:not(.solution-shown) .solution,
        body:not(.play) .solution {
            color: transparent;
        }
        body.free.solution-shown .path span.str { color: #F00; }

        .themaze.size3 { width: 270px; }
        .themaze.size4 { width: 320px; }
        .themaze.size5 { width: 370px; }
        .themaze.size6 { width: 420px; }
        .themaze.size7 { width: 470px; }
        .themaze:is(.size8,.size9,.size10){ width: 520px; }
        .square {
            cursor: pointer;
            user-select: none;
            transition: 0.2s;
        }
        .square text {
            pointer-events: none;
        }

        .square.selected .netsquare {
            stroke-width: 7.5px;
            stroke-dasharray: 10,5;
            stroke: #D80;
        }
        .square:is(.first,.start,.goal) text { fill: #000; }
        .square.goal .netsquare { fill: #00FF00AA; }
        .square.start .netsquare { fill: #FF0000AA; }
        .square.first .netsquare { fill: #3333FFAA; }
        .square.first.start .netsquare { fill: #FF00FFAA; }
        .square.first.goal .netsquare { fill: #00FFFFAA; }

        .sizetext {
            font-size: 20px;
            padding-top: 8px;
        }
        .sizeNumber {
            position: relative;
            top: 2px;
            font-size: 35px;
            width: 60px;
            margin-left: 10px;
            margin-right: 10px;
            text-align: center;
        }
        .sizeHolder button {
            padding-top: 12px;
            height: 32px;
            display: flex;
            align-items: center;
        }

        .invis {
            color: transparent;
            background-color: transparent;
            border-color: transparent;
            user-select: none;
            pointer-events: none;
        }
        .square-row.invis, .square.invis, .letters .square.invis {
            width: 0; height: 0;
            font-size: 0;
            border: 0;
        }

        .inputs input {
            width: 70px;
            margin: 3px;
            text-align: center;
        }

        button {
            font-family: Special Elite;
            background-color: white;
            color: black;
            font-size: 18px;
            border-radius: 5px;
            border: black 3px solid;
            padding: 7px 10px;
            transition: color 1s, background-color 1s;
            margin: 2.5px;
        }
        body:is(.size7, .size8, .size9, .size10) .toolset1 {
            display: none;
        }
        body:not(.size7, .size8, .size9, .size10) .toolset2 {
            display: none;
        }
        .button-spc { height: 29px; }
        .arrows button {
            height: 35px;
            width: 35px;
            font-size: 30px;
            padding: 0;
            line-height: 1.3;
            margin: 0;
        }
        button.btn-a {
            margin-right: -2.5%;
            transform: rotateZ(90deg);
        }
        button.btn-d {
            margin-left: -2.5%;
            transform: rotateZ(-90deg);
        }
        button.btn-w {
            transform: rotateZ(180deg);
        }

        button:hover {
            background-color: black;
            color: white;
        }
        button.flash {
            color: white;
            background-color: blue;
        }
        button.read-solve.solve::before {
            content: 'Solve';
        }
        button.read-solve:not(.solve)::before {
            content: 'Read';
        }
        button.movement, button.show-sol {
            padding: 3px 3px 1px 3px;
        }
        button.movement.free::before,
        body:not(.solve) button.movement::before {
            content: 'Free Movement';
        }
        button.movement:not(.free)::before,
        body.play button.movement::before {
            content: 'Enforced Movement';
        }

        body.play button.movement,
        body:is(.solve, .play) .goaltool,
        body:is(.solve, .play) .starttool,
        body:is(.solve, .play) .firsttool,
        body:is(.solve, .play) .inputs input,
        body:is(.solve, .play) button.clear-read,
        body:not(.play) button.radar,
        body:not(.solve) button.movement {
            user-select: none;
            pointer-events: none;
            background-color: #555;
        }
        body:is(.solve, .play) .goaltool {
            background-color: #00FF00AA;
            color: #000;
        }
        body:is(.solve, .play) .starttool {
            background-color: #FF0000AA;
            color: #000;
        }
        body:is(.solve, .play) .firsttool {
            background-color: #3333FFAA;
            color: #000;
        }
        button.expert-play.play::before {
            content: 'Generated';
        }
        button.expert-play:not(.play)::before {
            content: 'Manual';
        }
        button.sound.play::before {
            content: 'Sound';
        }
        button.sound:not(.play)::before {
            content: 'Muted';
        }
        button.show-sol.show::before {
            content: 'Solution Shown';
        }
        button.show-sol:not(.show)::before {
            content: 'Solution Hidden';
        }

        .page {
            background-position: top;
            background-repeat: repeat-y;
        }
    </style>
</head>
<body>
    <div class="section">
        <div class="page page-bg-03">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Mazeseeker</span>
            </div>
            <div class="page-content">
                <img src="img/Component/Mazeseeker.svg" class="diagram">
                <h2>On the Subject of Mazeseeker</h2>
                <p class="flavour-text">Everything you need is right in front of you, probably stolen off of a restaurant placemat.</p>

                <p>This module initially presents a central display with a digit on it, four arrow keys, a selectable LED and a smaller display at the bottom right, with a number on it.
                   You are on a random tile of a maze, whose walls you cannot see. The module is currently in <strong>“discovery”</strong> mode, meaning that walking through its walls bears no consequence.
                   Pressing the display changes the mode to <strong>“submission”</strong> mode.</p>
                <p>To solve this module, you must get from one location of the maze, the <strong>“start”</strong>, to another, the <strong>“goal”</strong>, while the module is in submission mode.
                   Once on the goal, pressing the display again will solve the module. Walking into any walls in submission mode or pressing the display again while on a non-goal tile will cause a strike and reset the module back to discovery mode.</p>

                <h3>Finding the Layout of the Maze</h3>

                <p>Each tile has a digit associated with it. This digit represents the number of walls surrounding the tile, like Minesweeper.
                   The maze is six tiles long by six tiles tall and is surrounded by walls. Here is an example:</p>

                <table class="mazediagram">
                <tr>
                    <th class="up left">2</th>
                    <th class="down up">2</th>
                    <th class="right down up">3</th>
                    <th class="up left">2</th>
                    <th class="down up">2</th>
                    <th class="right down up">3</th>
                </tr>

                <tr>
                    <th class="left">1</th>
                    <th class="down up">2</th>
                    <th class="right up">2</th>
                    <th class="right left">2</th>
                    <th class="up left">2</th>
                    <th class="right up">2</th>
                </tr>

                <tr>
                    <th class="down left">2</th>
                    <th class="right up">2</th>
                    <th class="down left">2</th>
                    <th class="right down">2</th>
                    <th class="right down left">3</th>
                    <th class="right left">2</th>
                </tr>

                <tr>
                    <th class="right up left">3</th>
                    <th class="right left">2</th>
                    <th class="up left">2</th>
                    <th class="down up">2</th>
                    <th class="right up">2</th>
                    <th class="right left">2</th>
                </tr>

                <tr>
                    <th class="right left">2</th>
                    <th class="down left">2</th>
                    <th class="right down">2</th>
                    <th class="right up left">3</th>
                    <th class="right left">2</th>
                    <th class="right left">2</th>
                </tr>

                <tr>
                    <th class="down left">2</th>
                    <th class="down up">2</th>
                    <th class="down up">2</th>
                    <th class="down">1</th>
                    <th class="down">1</th>
                    <th class="right down">2</th>
                </tr>

                </table>

                <h3>The LED</h3>

                <p>In discovery mode, the LED changes colour depending on what tile you are on. The tile is not special if it causes the LED to turn/remain off.
                   Red denotes the start, green signifies the goal and blue locates the top-left cell of the maze.
                   If the start is at the top-left of the maze, it will be magenta. If the goal is at the top-left, it will be cyan.</p>
                <p>While working out the layout of the maze, you may get stuck. In that case, you can “radar” (reveal the walls surrounding) a tile while in discovery mode.
                   To radar a tile, move to the tile that you would like to radar, then press the LED. Some arrows may get brighter, denoting a wall in their directions.
                   This radar has a cooldown, starting at 30 seconds for the first radar, then 60 seconds for the second, then 90 seconds for all others.
                   This cooldown is shown on the bottom-right display. Moving from and returning to a previously radared tile will show the radar again, thus you cannot radar a tile twice.</p>

                   <h3>Some Things to Note</h3>

                   <p>Moving while in submission mode will impact where you end up in discovery mode after a strike. For example, if you move right from the start in submission mode then strike, moving left will put you on the start again.</p>
   
                   <p>Movement in discovery mode wraps around (eg. moving left from tile A1 will bring you to tile F1).</p>
   
                   <h3>Keyboard Support</h3>
   
                   <p>This module has keyboard support, meaning that you can use your keyboard to move, radar and submit. You can move using WASD or the arrow keys, radar with E, and press the display with the return key.</p>

                </div>
            <div class="page-footer relative-footer">Page 1 of 2</div>
        </div>
        <div class="page page-bg-02">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Mazeseeker</span>
            </div>
            <div class="page-content">
                <div class="hstack gap">
                    <span>Shift the maze before inputting the walls.</span>
                    <div>
                        <input type="radio" id="shift-maze" name="rotate" value="left" checked>
                        <label for="shift-maze">Shift</label>
                    </div>
                    <div>
                        <input type="radio" id="input-walls" name="rotate" value="right">
                        <label for="input-walls">Input Walls</label>
                    </div>
                </div>
                <div class="hstack wrap">
                    <div class="vstack tools">
                        <div class="vstack toolset toolset2">
                            <div class="hstack arrows">
                                <button class="btn-a">▼</button>
                                <div class="vstack">
                                    <button class="btn-w">▼</button>
                                    <div class="button-spc"></div>
                                    <button class="btn-s">▼</button>
                                </div>
                                <button class="btn-d">▼</button>
                            </div>
                            <div class="othertools"></div>
                        </div>
                    </div>
                    <svg class="themaze size6" viewbox="0 0 650 650" xmlns="http://www.w3.org/2000/svg"></svg>
                    <div class="vstack toolset toolset1">
                        <div class="hstack arrows">
                            <button class="btn-a">▼</button>
                            <div class="vstack">
                                <button class="btn-w">▼</button>
                                <div class="button-spc"></div>
                                <button class="btn-s">▼</button>
                            </div>
                            <button class="btn-d">▼</button>
                        </div>
                        <div class="othertools"></div>
                    </div>
                </div>
                <div style="height: 5mm"></div>
                <div class="saves hstack wrap just-left">
                    <button class="save">Save</button>
                </div>
                <div class="hstack just-left" style="margin-top: 5mm">
                    <button class="radar">Radar Cell</button>
                    <button class="reset-walls">Reset Walls</button>
                    <button class="reset-saves">Reset Saves</button>
                    <button class="reset-all">Reset All</button>
                    <div style="width: 8mm"></div>
                    <div class="sizeHolder hstack">
                        <div class="sizetext label">Size:</div>
                        <div class="sizetext sizeNumber">4</div>

                        <button class="sizetext minus">-</button>
                        <button class="sizetext plus">+</button>
                    </div>
                </div>
                <div style="height: 5mm"></div>
                <div class="hstack just-left path"><span>Path:</span><span class="str"></span></div>
                <div style="height: 1mm"></div>
                <div class="hstack just-left solution"><span>Solution:</span><span class="str"></span></div>

                <h3>Interactive Controls</h3>
                <p>Use the above interactive graphic to input the read and try out different paths.</p>
                <ul>
                    <li>
                        In <b>Read</b> mode:
                        <ul>
                            <li>Select a <b>cell</b> and type <b>[0]-[4]</b> on your keyboard to input the puzzle grid. <b>Space</b>/<b>Enter</b> to clear.</li>
                            <li>Use the <b>Goal</b>, <b>Start</b>, and <b>Corner</b> tool to mark the <b>goal</b>, <b>start</b>, and <b>top-left corner</b> position</li>
                            <li><u>First</u> use the <b>arrow buttons</b>, or <b>WASD</b>, or <b>arrow keys</b> on your keyboard to <b>shift the maze</b> so the corner cell is in the top-left corner.</li>
                            <li><u>Then</u> select <b>Input Walls</b> and use the <b>arrow keys</b> to input the walls of a selected <b>cell</b></li>
                        </ul></li>
                    <li>In <b>Solve</b> mode, the grid behaves like the module with options for <em>free</em> movement or <em>enforced</em> movement as the module demands.</li>
                    <li>Use the <b>arrow buttons</b>, or <b>WASD</b>, or <b>arrow keys</b> on your keyboard to navigate the maze.</li>
                    <li>Your <b>Path</b> may be invalid if you turn off enforced movement in <b>Solve</b> mode</li>
                    <li>The <b>↻</b> button resets the position back to the start.</li>
                    <li>The sound effects can be muted.</li>
                    <li>
                        Press the <b>Manual</b> button to switch into <b>Generated</b> mode:
                        <ul>
                            <li>Have fun solving generated puzzles of size 3 – 10.</li>
                            <li>Use the <b>Radar</b> button to see the correct walls of a cell in a generated puzzle, just like the real module.</li>
                            <li>Use the <b>-</b> and <b>+</b> buttons or press <b>[-]</b> and <b>[+]</b> on your keyboard to increment the size of the generated puzzle.</li>
                        </ul></li> 
                    <li>The solution you came up with in <b>Solve</b> mode as well as the solution to generated puzzles can be <em>shown</em> or <em>hidden</em>.<br></li>
                    <li>Using the other buttons, you can save the current state of the grid, delete the saves, or reset everything.</li>
                </ul>
            </div>
            <div class="page-footer relative-footer">Page 2 of 2</div>
        </div>
    </div>
</body>
</html>