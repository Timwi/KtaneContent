<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <title>Game of Ants — Keep Talking and Nobody Explodes Module</title>
    <link rel="stylesheet" type="text/css" href="css/font.css">
    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/main.css">
    <script src="js/ktane-utils.js"></script>
    <script src="js/jquery.3.7.0.min.js"></script>
    <script src="js/Utilities/svg-utils.js"></script>
    <script src="js/Utilities/math-utils.js"></script>
    <script src="js/Utilities/ui-utils.js"></script>
    <script>
    $(function() {
        let selected;
        let selectedTool;
        let rotating = false;
        let golgrid = $(".grid.gol-grid");
        let grid = $(".grid.ant-grid");
        let generating = false;
        let saveStates = [];
        let currentState = 0;
        let readState;
        const rows = 5;
        const cols = 5;
        const nAnts = 5;
        const animDelay = 1800;
        let currX = 0;
        let currY = 0;
        let gameGrid = Array(rows).fill().map(()=>Array(cols).fill(false));
        let origGameGrid = Array(rows).fill().map(()=>Array(cols).fill(false));
        let animTimeout = null;
        const MODE_READ = 0;
        const MODE_SOLVE = 1;
        const MODE_PLAY = 2;
        const MODE_GOL = 3;
        const MODE_ANT = 4;

        let squareColors = ["white", "black"];
        const directions = {
            Up: [0, -1],
            Left: [-1, 0],
            Down: [0, 1],
            Right: [1, 0],
            w: [0, -1],
            a: [-1, 0],
            s: [0, 1],
            d: [1, 0],
            0: [0, -1],
            1: [-1, 0],
            2: [0, 1],
            3: [1, 0]
        }
        const dirIndex = {
            Up: 0,
            Right: 1,
            Down: 2,
            Left: 3,
            w: 0,
            d: 1,
            s: 2,
            a: 3,
        };

        function selectNone() {
            selectedTool = null;
            rotating = false;
            updateSelection();
        }

        function updateSelection() {
            $(".selected").removeClass("selected");
            if (selected && selected.length > 0) {
                selected.addClass("selected");
            }
        }

        function saveReadState() {
            readState = Array.from($(".netsquare, .ant-child")).map(x => $(x)).map(x => x.attr("class") || "");
        }

        function resetPos() {
            if (readState) {
                $(".netsquare, .ant-child").each((i, x) => $(x).attr("class", readState[i]));
            }
            selected = $(".antsquare.x0.y0");
            selectNone();
            currX = currY = 0;
            gameGrid = JSON.parse(JSON.stringify(origGameGrid));
            $(".leave-button").removeClass("leave");
        }

        function coordinateName(coord) {
            return `${String.fromCharCode(65 + coord[1])}${coord[0] + 1}`;
        }

        function hasWhichColor(elem) {
            for (var i = 0; i < squareColors.length; i++) {
                if (elem.hasClass(squareColors[i])) return i;
            }
            return -1;
        }

        function nextColor(elem) {
            let c = hasWhichColor(elem);
            removeColorClass(elem);
            elem.addClass(squareColors[(c + 1) % squareColors.length]);
        }

        function removeColorClass(elem) {
            elem.removeClass("white black");
        }

        function hasWhichAnt(elem) {
            for (var i = 1; i <= nAnts; i++) {
                if (elem.hasClass(`ant${i}`)) return i;
            }
            return -1;
        }

        function removeOthers(which, manual = true) {
            let antClass = `ant${which}`;
            $(`.netsq.ant.${antClass}`).removeClass(`ant ${antClass} arot0 arot1 arot2 arot3`);
            let antChild = $(`.ant-child.${antClass}`).first();
            if (antChild.length > 0) {
                let parent = antChild.parent();
                antChild.removeClass(`ant ${antClass} arot0 arot1 arot2 arot3`);
                antChild = parent.find(".ant-child.ant");
                if (antChild.length == 1) {  //only one ant remains, convert back to single ant cell
                    let a = hasWhichAnt(antChild);
                    let r = hasWhichRot(antChild);
                    parent.removeClass("multiple ant");
                    if (manual) {
                        setTimeout(function() {
                            antChild.removeClass(`ant ant${a} arot${r}`);
                            if ($(`.netsq.ant.ant${a}`).length == 0 && $(`.ant-child.ant.ant${a}`).length == 0)
                                parent.addClass(`ant ant${a} arot${r}`);
                        }, 100);
                    }
                    else {
                        antChild.removeClass(`ant ant${a} arot${r}`);
                        parent.addClass(`ant ant${a} arot${r}`);
                    }
                }
            }
        }

        function setAnt(elem, which = 1, rot = 0, manual = true) {
            let antClass = `ant${which}`;
            let rotClass = `arot${rot}`;
            if (elem.hasClass("ant")) {
                if (elem.hasClass("multiple")) {    //already multiple ants here
                    let antChild = elem.find(`.ant-child.${antClass}`).first();
                    if (antChild.length > 0) {  //ant-child already has this type
                        if (antChild.hasClass(rotClass)) {  //and rotation, remove entirely
                            if (manual) removeOthers(which);
                        } else {                            //give new rotation
                            antChild.removeClass(`arot0 arot1 arot2 arot3`).addClass(rotClass);
                        }
                    }
                    else {  //no ant-child has this type yet
                        removeOthers(which, manual);
                        antChild = elem.find(".ant-child:not(.ant)").first();
                        if (antChild.length > 0) {  //there is an available slot
                            antChild.addClass(`ant ${antClass} ${rotClass}`);
                        }
                    }
                }
                else {  //exactly one ant here so far
                    if (elem.hasClass(antClass)) {  //the one ant is already this type
                        if (elem.hasClass(rotClass)) {  //and matching rotation, remove entirely
                            if (manual) removeAnts(elem);
                        } else {                        //but not rotation, give new rotation
                            elem.removeClass(`arot0 arot1 arot2 arot3`).addClass(rotClass);
                        }
                    }
                    else {  //turn into a shared cell and add new ant
                        removeOthers(which, manual);
                        antChild = elem.find(".ant-child:not(.ant)").first();
                        elem.addClass("multiple");
                        let a = hasWhichAnt(elem);
                        let r = hasWhichRot(elem);
                        elem.removeClass(`ant${a} arot${r}`);
                        antChild.addClass(`ant ant${a} arot${r}`);          //place parent ant in first cell
                        antChild = elem.find(".ant-child:not(.ant)").first();
                        antChild.addClass(`ant ${antClass} ${rotClass}`);   //place new ant in second cell
                    }
                }
            }
            else {
                removeOthers(which, manual);
                removeAnts(elem);
                elem.addClass(`ant ant${which} arot${rot}`);
            }
        }

        function removeAnts(elem) {
            const classes = "ant multiple arot0 arot1 arot2 arot3 ant1 ant2 ant3 ant4 ant5";
            elem.removeClass(classes);
            elem.find(".ant-child").removeClass(classes);
        }

        function nextRotation(elem, cc = false) {
            let c = hasWhichRot(elem);
            let rot = UMod(c + (cc ? -1 : 1), 4);
            elem.removeClass("arot0 arot1 arot2 arot3").addClass(`arot${rot}`);
            return rot;
        }

        function hasWhichRot(elem) {
            for (var i = 0; i < 4; i++)
                if (elem.hasClass(`arot${i}`)) return i;
            return -1;
        }

        const antdir = [
            [], [2], [2], [2], [],
            [1], [1, 2], [1, 2, 3], [2, 3], [3],
            [1], [0, 1, 2], [0, 1, 2, 3], [0, 2, 3], [3],
            [1], [0, 1], [0, 1, 3], [0, 3], [3],
            [], [0], [0], [0], []
        ];
        const dirs = "URDL";

        let antSteps = [];
        let gridStates = [];
        let animStep = 0;

        function isSolved() {
            if (mode() !== MODE_PLAY) return false;

            // Check ant positions and orientations
            let antPositions = {};
            for (let [y, x, r] of antSteps[antSteps.length - 1]) {
                let elem = $(`.netsq.x${x}.y${y}`);
                if (elem.length > 0) {
                    if (!elem.hasClass("ant")) {
                        console.log(coordinateName([y,x]), "ant mismatch");
                        return false;
                    }
                    if (!elem.hasClass(`arot${r}`)) {
                        console.log(coordinateName([y,x]), `arot${r} mismatch`);
                        return false;
                    }
                }
                // else console.log(coordinateName([y,x]), "does not exist");
            }
            console.log("ants match");

            let correctButtons = [];
            // Check leave buttons
            for (let ant of antSteps[antSteps.length - 1]) {
                if (ant[0] < 0 || ant[0] >= rows || ant[1] < 0 || ant[1] >= cols) {
                    let leaveButtonQ = ant[0] < 0 ? `.btn-w.l${ant[1]}` :
                        ant[0] >= rows ? `.btn-s.l${ant[1]}` :
                        ant[1] < 0 ? `.btn-a.l${ant[0]}` : `.btn-d.l${ant[0]}`;
                    let leaveButton = $(leaveButtonQ);
                    correctButtons.push(leaveButton.attr("class"));
                    if (leaveButton.length < 1 || !leaveButton.hasClass("leave")) {
                        console.log(`${leaveButtonQ} mismatch`);
                        return false;
                    }
                }
            }
            let selectedButtons = $(".leave-button.leave");
            if (correctButtons.length != selectedButtons.length) {
                console.log("extra exits");
                return false;
            }
            console.log("exits match");

            // Check grid colors
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let elem = $(`.netsq.x${x}.y${y}`);
                    let expected = gridStates[gridStates.length - 1][y][x];
                    if (elem.hasClass("white") !== expected) {
                        console.log(coordinateName([y,x]), "grid mismatch");
                        return false;
                    }
                }
            }
            console.log("grid matches");
            if ($("button.sound").hasClass("play")) {
                audioSolve[0].play();
            }

            return true;
        }

        function animate() {
            // Reset the grid to the initial state
            resetPos();

            // Start the animation
            animStep = 0;
            animTimeout = setTimeout(animateStep, animDelay);
        }

        function animateStep() {
            if (animStep <= antSteps.length) {
                // Display each step of ant movement
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        let elem = $(`.netsq.x${x}.y${y}`);
                        removeColorClass(elem);
                        elem.addClass(squareColors[gridStates[animStep][y][x] ? 0 : 1]);
                    }
                }
                if (animStep > 0) {
                    antSteps[animStep - 1].forEach((ant, i) => {
                        if (ant[0] < 0 || ant[0] >= rows || ant[1] < 0 || ant[1] >= cols) {
                            // console.log("ant", ant);
                            if (ant[0] < 0) {
                                $(`.btn-w.l${ant[1]}`).addClass("leave");
                            }
                            if (ant[0] >= rows) {
                                $(`.btn-s.l${ant[1]}`).addClass("leave");
                            }
                            if (ant[1] < 0) {
                                $(`.btn-a.l${ant[0]}`).addClass("leave");
                            }
                            else {
                                $(`.btn-d.l${ant[0]}`).addClass("leave");
                            }
                            removeOthers(i + 1);
                        }
                        else {
                            setAnt($(`.antsquare.x${ant[1]}.y${ant[0]}`), i + 1, ant[2], false);
                        }
                    });
                }
            } else {
                // Display the final grid state
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        let elem = $(`.netsq.x${x}.y${y}`);
                        removeColorClass(elem);
                        elem.addClass(squareColors[gridStates[animStep][y][x] ? 0 : 1]);
                    }
                }
                $(".pause-button").addClass("pause");
                return;
            }

            animStep++;
            animTimeout = setTimeout(animateStep, animDelay);
        }

        function generate() {
            if (generating) return;
            generating = true;

            // Clear previous data
            antSteps = [];
            gridStates = [];

            // Initialize the grid randomly
            for (let i = 0; i < 25; i++) {
                let r = Random(0, 2) > 0;
                let y = Math.floor(i / 5);
                let x = i % 5;
                gameGrid[y][x] = r;
                origGameGrid[y][x] = r;
                $(`.netsq.x${x}.y${y}`).removeClass("black white").addClass(r ? "white" : "black");
            }

            // console.log(`The initial state of the grid is:`);
            // console.log(gameGrid.map(row => row.map(cell => cell ? "□" : "■").join("")).join("\n"));

            // Perform one iteration of Game of Life
            gameGrid = G(gameGrid);
            gridStates.push(gameGrid.map(row => row.slice()));

            // console.log(`The life phase yields:`);
            // console.log(gameGrid.map(row => row.map(cell => cell ? "□" : "■").join("")).join("\n"));

            // Display life phase
            let svgsz = 112, xoff = 2, yoff = 2, dx = 22, dy = 22, sw = 20, sh = 20;
            let lifePhase = MakeSvgTag(svgsz, svgsz);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    lifePhase.append(MakeSvgElem("rect", {
                        x: x * dx + xoff,
                        y: y * dy + yoff,
                        width: sw,
                        height: sh,
                        stroke: "#888",
                        fill: gameGrid[y][x] ? "white" : "black"
                    }));
                }
            }
            $(".solution .life-phase").html("").append(lifePhase);

            // Initialize ants randomly
            let antnum = Random(2, 6);
            let antinit = [1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23];
            let antpos = [];
            for (let i = 0; i < antnum; i++) {
                let r = PickRandom(antinit);
                antinit = antinit.filter(x => x !== r);
                let y = Math.floor(r / 5);
                let x = r % 5;
                let d = PickRandom(antdir[r]);
                antpos.push([y, x, d]);
            }

            let antcoord = new Array(antnum);
            let antshare = new Array(antnum);
            let antlog = new Array(antnum);
            antpos.sort((a,b) => a[1] == b[1] ? (a[0] - b[0]) : (a[1] - b[1]));
            removeAnts($(".antsquare"));
            for (let i = 0; i < antnum; i++) {
                let ant = antpos[i];
                antlog[i] = coordinateName(ant) + ":";
                setAnt($(`.antsquare.x${ant[1]}.y${ant[0]}`), i + 1, ant[2]);
            }

            while (true) {
                let antStep = [];
                for (let i = 0; i < antnum; i++) {
                    Move(antpos[i], true);
                    antcoord[i] = antpos[i][0] * 6 + antpos[i][1];
                    antlog[i] += dirs[antpos[i][2]];
                    antStep.push([...antpos[i]]);
                }
                antSteps.push(antStep);
                gridStates.push(gameGrid.map(row => row.slice()));

                for (let i = 0; i < antnum; i++) {
                    antshare[i] = antcoord.filter((x, k) => k != i && x == antcoord[i]).length > 0 && antpos.map(x => x[2]).filter((x, k) => k > i && antcoord[k] == antcoord[i]).every(x => x != antpos[i][2]);
                }

                while (antshare.some(x => x)) {
                    antStep = [];
                    for (let i = 0; i < antnum; i++) {
                        if (antshare[i]) {
                            Move(antpos[i], false);
                            antcoord[i] = antpos[i][0] * 6 + antpos[i][1];
                            antlog[i] += dirs[antpos[i][2]];
                        }
                        else {
                            antlog[i] += "-";
                        }
                        antStep.push([...antpos[i]]);
                    }
                    antSteps.push(antStep);
                    gridStates.push(gameGrid.map(row => row.slice()));

                    for (let i = 0; i < antnum; i++) {
                        antshare[i] = antcoord.filter((x, k) => k != i && x == antcoord[i]).length > 0 && antpos.map(x => x[2]).filter((x, k) => k > i && antcoord[k] == antcoord[i]).every(x => x != antpos[i][2]);
                    }
                }

                if (antpos.some(x => x[0] < 0 || x[0] >= rows || x[1] < 0 || x[1] >= cols)) {
                    break;
                }

                //rotate
                for (let i = 0; i < antnum; i++) {
                    let ant = antpos[i];
                    if (ant[0] >= 0 && ant[0] < rows && ant[1] >= 0 && ant[1] < cols) {
                        ant[2] = (ant[2] + (gameGrid[ant[0]][ant[1]] ? 1 : 3)) % 4;
                    }
                }
            }

            for (let i = 0; i < antnum; i++) {
                let ant = antpos[i];
                antlog[i] += ":";
                if (ant[0] < 0) {
                    antpos[i][0] = -1;
                    antpos[i][2] = 0;
                    antlog[i] += "OUT N" + (ant[1] + 1);
                } else if (ant[0] > 4) {
                    antpos[i][0] = rows;
                    antpos[i][2] = 2;
                    antlog[i] += "OUT S" + (ant[1] + 1);
                } else if (ant[1] < 0) {
                    antpos[i][1] = -1;
                    antpos[i][2] = 3;
                    antlog[i] += "OUT W" + (ant[0] + 1);
                } else if (ant[1] > 4) {
                    antpos[i][1] = cols;
                    antpos[i][2] = 1;
                    antlog[i] += "OUT E" + (ant[0] + 1);
                } else {
                    antlog[i] += coordinateName(ant);
                }
            }

            // console.log(`The ants travel along the following paths:`);
            // console.log(antlog.join("\n"));

            // Display ant travel
            $(".solution .ant-travel").html(antlog.join("<br>"));

            // console.log(`The ant phase yields:`);
            // console.log(gameGrid.map(row => row.map(cell => cell ? "□" : "■").join("")).join("\n"));

            // Display ant phase
            let antPhase = MakeSvgTag(svgsz, svgsz);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    antPhase.append(MakeSvgElem("rect", {
                        x: x * dx + xoff,
                        y: y * dy + yoff,
                        width: sw,
                        height: sh,
                        stroke: "#888",
                        fill: gameGrid[y][x] ? "white" : "black"
                    }));
                }
            }
            $(".solution .ant-phase").html("").append(antPhase);

            // Perform another iteration of Game of Life
            gameGrid = G(gameGrid);

            // console.log(`The final state of the grid is:`);
            // console.log(gameGrid.map(row => row.map(cell => cell ? "□" : "■").join("")).join("\n"));

            // Display final state
            let finalState = MakeSvgTag(svgsz, svgsz);
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    finalState.append(MakeSvgElem("rect", {
                        x: x * dx + xoff,
                        y: y * dy + yoff,
                        width: sw,
                        height: sh,
                        stroke: "#888",
                        fill: gameGrid[y][x] ? "white" : "black"
                    }));
                }
            }
            $(".solution .final-state").html("").append(finalState);
            gridStates.push(gameGrid.map(row => row.slice()));

            generating = false;
        }

        function G(s) {
            let z = Array(5).fill().map(() => Array(5).fill(false));
            for (let i = 0; i < 25; i++) {
                let p = 0;
                for (let j = 0; j < 3; j++) {
                    let x = Math.floor(i / 5) + (j - 1);
                    if (x < 0 || x > 4) continue;
                    for (let k = 0; k < 3; k++) {
                        let y = (i % 5) + (k - 1);
                        if (y < 0 || y > 5) continue;
                        if (s[x][y]) p++;
                    }
                }
                if (p === 3 || (p === 4 && s[Math.floor(i / 5)][i % 5])) {
                    z[Math.floor(i / 5)][i % 5] = true;
                }
            }
            return z;
        }

        function Move(ant, toggle) {
            if (toggle) {
                gameGrid[ant[0]][ant[1]] = !gameGrid[ant[0]][ant[1]];
            }
            switch (ant[2]) {
                case 0: ant[0]--; break;
                case 1: ant[1]++; break;
                case 2: ant[0]++; break;
                default: ant[1]--; break;
            }
        }

        function Random(min, max) {
            return Math.floor(Math.random() * (max - min)) + min;
        }

        function PickRandom(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        function coordinate(pos) {
            return [ pos % cols, Math.floor(pos / cols) ];
        }

        let autoclick = false;
        function arrowPressed(direction, dirIdx) {
            if (selected && mode() != MODE_READ && selected.hasClass("ant")) {
                let ant = selected.hasClass("multiple") ? selected.find(".ant-child.ant").first() : selected;
                let antType = hasWhichAnt(ant);
                let x = currX + direction[0];
                let y = currY + direction[1];
                if (x < 0 || x >= cols || y < 0 || y >= rows) {
                    removeOthers(antType);
                    let leaveButton = direction[0] == -1 ? $(`.btn-a.l${currY}`) :
                        direction[0] == 1 ? $(`.btn-d.l${currY}`) :
                        direction[1] == -1 ? $(`.btn-w.l${currX}`) : $(`.btn-s.l${currX}`);
                    leaveButton.addClass("leave");
                } else {
                    let elem = $(`.antsquare.x${x}.y${y}`);
                    setAnt(elem, antType, dirIdx);
                    autoclick = true;
                    elem.click();
                }
                if (isSolved()) $(".solved-text").removeClass("invis");
                else $(".solved-text").addClass("invis");
            }
        }

        let down = false;
        $(document).click(function() {
            selectNone();
        }).keydown(function(event) {
            if (down)
                return false;
            down = true;
            let k = event.key.toLowerCase();
            if (event.key.startsWith("Arrow")) {
                let d = event.key.substring(5);
                arrowPressed(directions[d], dirIndex[d]);
                event.preventDefault();
            } else if (NoSpecialKeys(event) && (k == "w" || k == "a" || k == "s" || k == "d")) {
                arrowPressed(directions[k], dirIndex[k]);
                event.preventDefault();
            } else if (NoSpecialKeys(event)) {
                let n = parseInt(event.key);
                if (k == " " || k == "enter" || (n >= 0 && n <= 1)) {
                    if (k == " " || k == "enter" || n == 0) {
                        playZeroOneSound(false);
                        removeColorClass(selected);
                        selected.addClass("black");
                        gameGrid[currY][currX] = false;
                    }
                    else {
                        playZeroOneSound(true);
                        removeColorClass(selected);
                        selected.addClass("white");
                        gameGrid[currY][currX] = true;
                    }
                    if (mode() == MODE_READ) {
                        if (currX == cols - 1)
                            currY = (currY + 1) % cols;
                        currX = (currX + 1) % rows;
                        selected = $(`.golsquare.x${currX}.y${currY}`);
                        updateSelection();
                    }
                }
            }
            down = false;
            if (k == " " || k == "enter") return false;
        });

        $(".arrows button").click(function(event) {
            let q = this.className.split("-")[1];
            arrowPressed(directions[q], dirIndex[q]);
            event.preventDefault();
            event.stopPropagation();
        });

        function mode() {
            if ($("button.expert-play").hasClass("play"))
                return MODE_PLAY;
            else if ($("button.read-solve").hasClass("solve"))
                return MODE_SOLVE;
            else
                return MODE_READ;
        }

        let row = $("<div>").addClass("square-row letters").appendTo(golgrid);
        $("<div>").addClass("square").appendTo(row);
        for (var i = 0; i < cols; i++) {
            $("<div>").addClass("square").text(String.fromCharCode(65 + i)).appendTo(row);
        }
        for (let y = 1; y <= rows; y++) {
            row = $("<div>").addClass("square-row").appendTo(golgrid);
            $("<div>").addClass("square numbers").text(y).appendTo(row);
            for (let x = 1; x <= cols; x++) {
                let square = $("<div>").addClass(`netsquare square netsq golsquare x${x-1} y${y-1} black`).appendTo(row).each(function(_, e) {
                    var element = $(e);
                    element.click(function() {
                        let group = $(`.netsquare.x${x-1}.y${y-1}`);
                        nextColor(group);
                        selected = $(`.golsquare.x${x-1}.y${y-1}`);
                        let n = selected.hasClass("white");
                        updateSelection();
                        currX = x-1;
                        currY = y-1;
                        origGameGrid[y-1][x-1] = gameGrid[y-1][x-1] = n;
                        if (isSolved()) $(".solved-text").removeClass("invis");
                        else {
                            $(".solved-text").addClass("invis");
                            playZeroOneSound(n);
                        }
                    }).contextmenu(function() {
                        $(this).toggleClass("dot");
                        playDZeroOneSound($(this).hasClass("dot"));
                        return false;
                    });
                });
            }
        }
        row = $("<div>").addClass("square-row letters").appendTo(grid);
        $("<div>").addClass("square").appendTo(row);
        $("<div>").addClass("arrow-spacer").appendTo(row);
        for (var x = 0; x < cols; x++) {
            $("<div>").addClass("square").text(String.fromCharCode(65 + x)).appendTo(row);
        }
        row = $("<div>").addClass("hstack arrow-row").appendTo(grid);
        $("<div>").addClass("square-spacer").appendTo(row);
        $("<div>").addClass("arrow-spacer").appendTo(row);
        //add leave buttons
        for (var x = 0; x < cols; x++) {
            let holder = $("<div>").addClass("square-spacer vstack alignc").appendTo(row);
            $("<button>").addClass(`leave-button btn-w l${x}`).text("▼").appendTo(holder);
        }
        for (let y = 1; y <= rows; y++) {
            row = $("<div>").addClass("square-row").appendTo(grid);
            $("<div>").addClass("square numbers").text(y).appendTo(row);
            //add leave buttons
            $("<button>").addClass(`leave-button btn-a l${y-1}`).text("▼").appendTo(row);
            for (let x = 1; x <= cols; x++) {
                let square = $("<div>").addClass(`netsquare square antsquare netsq x${x-1} y${y-1} black`).appendTo(row).each(function(_, e) {
                    var element = $(e);
                    element.click(function(event) {
                        if (rotating || event.ctrlKey || event.metaKey || event.shiftKey) {
                            let antElems = element.hasClass("multiple") ? element.find(".ant-child.ant") : element;
                            antElems.each(function() {
                                nextRotation($(this), event.shiftKey);
                            });
                            return false;
                        }
                        if (selectedTool && selectedTool.startsWith("ant")) {
                            for (let a = 1; a <= nAnts; a++) {
                                if (selectedTool.startsWith(`ant ant${a}`)) {
                                    let r = parseInt(selectedTool.split("arot")[1]);
                                    setAnt(element, a, r);
                                    break;
                                }
                            }
                            return false;
                        }
                        let group = $(`.antsquare.x${x-1}.y${y-1}`);
                        selected = group;
                        updateSelection();
                        currX = x-1;
                        currY = y-1;

                        if (!autoclick) {
                            nextColor($(`.netsq.x${x-1}.y${y-1}`));
                            let n = group.hasClass("white");
                            if (isSolved()) $(".solved-text").removeClass("invis");
                            else {
                                $(".solved-text").addClass("invis");
                                playZeroOneSound(n);
                            }
                            gameGrid[y-1][x-1] = n;
                        }
                        autoclick = false;
                    });
                    element.contextmenu(function() {
                        let group = $(`.antsquare.x${x-1}.y${y-1}`);
                        selected = group;
                        updateSelection();
                        currX = x-1;
                        currY = y-1;
                        return false;
                    });
                    
                    //add child squares
                    for (let i = 0; i < 4; i++) {
                        $("<div>").addClass(`ant-child ant-child-${i}`).appendTo(element);
                    }
                });
            }
            //add leave buttons
            $("<button>").addClass(`leave-button btn-d l${y-1}`).text("▼").appendTo(row);
        }
        row = $("<div>").addClass("hstack arrow-row").appendTo(grid);
        $("<div>").addClass("square-spacer").appendTo(row);
        $("<div>").addClass("arrow-spacer").appendTo(row);
        //add leave buttons
        for (var x = 0; x < cols; x++) {
            let holder = $("<div>").addClass("square-spacer vstack alignc").appendTo(row);
            $("<button>").addClass(`leave-button btn-s l${x}`).text("▼").appendTo(holder);
        }

        $(".leave-button").click(function() {
            $(this).toggleClass("leave");
            if (isSolved()) $(".solved-text").removeClass("invis");
            else $(".solved-text").addClass("invis");
        });

        resetPos();
        selected = $(".golsquare.x0.y0");
        updateSelection();

        function playZeroOneSound(on) {
            if ($("button.sound").hasClass("play")) {
                let aud = on ? audio1[0].cloneNode() : audio0[0].cloneNode();
                aud.volume = 0.8;
                aud.play();
            }
        }
        function playDZeroOneSound(on) {
            if ($("button.sound").hasClass("play")) {
                let aud = on ? audiod1[0].cloneNode() : audiod0[0].cloneNode();
                aud.volume = 0.8;
                aud.play();
            }
        }

        let audio0 = $("<audio>")
            .attr("src", "audio/Not The Bulb/TapCode.wav")
            .appendTo(grid);
        let audio1 = $("<audio>")
            .attr("src", "audio/Not The Bulb/NonoClick.wav")
            .appendTo(grid);
        let audio2 = $("<audio>")
            .attr("src", "audio/Not The Bulb/SelectBulb.wav")
            .appendTo(grid);
        let audiod0 = $("<audio>")
            .attr("src", "audio/Old Fogey/BigButtonRelease.wav")
            .appendTo(grid);
        let audiod1 = $("<audio>")
            .attr("src", "audio/Old Fogey/BigButtonPress.wav")
            .appendTo(grid);
        let audioSolve = $("<audio>")
            .attr("src", "audio/Module Listening/Encrypted Equations - Solve.wav")
            .appendTo(grid);

        let tools = $(".tools");

        $("<div>").addClass("tool rotatetool").text("Rotate").appendTo(tools).click(function() {
            $(".tool").removeClass("selected");
            $(this).addClass("selected");
            rotating = true;
            event.preventDefault();
            event.stopPropagation();
        });
        
        $("<button>").addClass("read-solve").appendTo(tools).click(function() {
            $(this).toggleClass("solve");
            $("body").toggleClass("solve", $(this).hasClass("solve"));

            if (mode() == MODE_SOLVE) {
                saveReadState();
            }
            if (mode() != MODE_READ) {
                resetPos();
            }
        });
        $("<button>").addClass("sound play").appendTo(tools).click(function() {
            $(this).toggleClass("play");
        });
        $("<button>").addClass("expert-play").appendTo(tools).click(function() {
            if (generating)
                return false;
            $(this).toggleClass("play");
            $("body").toggleClass("play", $(this).hasClass("play"));
            if (mode() == MODE_PLAY) {
                $("body").removeClass("solution-shown");
                $("button.show-sol").removeClass("show");
                $("button.pause-button").removeClass("pause");
                generate();
                saveReadState();
            }
            clearTimeout(animTimeout);
            resetPos();
        });
        $("<button>").addClass("show-sol").appendTo(tools).click(function() {
            $(this).toggleClass("show");
            let show = $(this).hasClass("show");
            $("body").toggleClass("solution-shown", show);
            clearTimeout(animTimeout);
            if (show && mode() == MODE_PLAY) {
                $(".solved-text").addClass("invis");
                $("button.pause-button").removeClass("pause");
                animate();
            }
            else {
                resetPos();
            }
        });
        $("<button>").addClass("pause-button").appendTo(tools).click(function() {
            $(this).toggleClass("pause");
            if ($(this).hasClass("pause")) {
                clearTimeout(animTimeout);
            }
            else {
                animTimeout = setTimeout(animateStep, animDelay);
            }
        });

        let othertools = $("<div>").addClass("othertools square-row letters").appendTo(grid);
        $("<div>").addClass("square").appendTo(othertools);
        $("<div>").addClass("arrow-spacer").appendTo(othertools);
        for (let i = 0; i < nAnts; i++) {
            $("<div>").addClass(`tool ant arot0 ant${i+1}`).appendTo(othertools).click(function(event) {
                let elem = $(this);
                if (event.ctrlKey || event.metaKey || event.shiftKey) {
                    let rot = nextRotation(elem, event.shiftKey);
                    if (elem.hasClass("selected"))
                        selectedTool = `ant ant${i+1} arot${rot}`;
                    return false;
                }
                if (rotating) {
                    nextRotation(elem, event.shiftKey);
                    return false;
                }
                $(".tool").removeClass("selected");
                elem.addClass("selected");
                let r = hasWhichRot(elem);
                selectedTool = `ant ant${i+1} arot${r}`;
                event.preventDefault();
                event.stopPropagation();
            });
        }
        $("<div>").css("width", "5px").appendTo(othertools);
        $("div.tool.reset-grid").click(function(event) {
            resetPos();
            event.preventDefault();
            event.stopPropagation();
        });

        $("button.clear-dots").click(function() {
            $(".gol-grid .dot").removeClass("dot");
        })

        $(".reset-saves").click(function() {
            saveStates.forEach(x => x.remove());
            saveStates = [];
            currentState = 0;
        });
        $(".reset-all").click(function() {
            resetPos();
            $(".solved-text").addClass("invis");
            $("body").removeClass("solution-shown solve play");
            $("button.sound").addClass("play");
            $("button.expert-play").removeClass("play");
            $("button.show-sol").removeClass("show");
            $("button.read-solve").removeClass("solve");
            $(".leave-button").removeClass("leave");
            $(".netsq").removeClass(squareColors.join(" ")).addClass("black");
            removeAnts($(".antsquare"));
            $(".tool.ant").removeClass("arot1 arot2 arot3").addClass("arot0");
            let gameGrid = Array(cols).fill().map(()=>Array(rows).fill(false));
            let origGameGrid = Array(cols).fill().map(()=>Array(rows).fill(false));
            selected = $(".golsquare.x0.y0");
            updateSelection();

            saveStates.forEach(x => x.remove());
            saveStates = [];
            currentState = 0;
        });

        function removeFutureSaves() {
            if (currentState < saveStates.length - 1) {
                for (let i = currentState + 1; i < saveStates.length; i++) {
                    saveStates[i].remove();
                }
                saveStates.splice(currentState + 1, saveStates.length - currentState);
            }
        }

        $("button.save").click(function() {
            removeFutureSaves();

            let saveStateClass = Array.from($(".netsquare, .ant-child, .tools button, .tool.ant, .leave-button")).map(x => $(x)).map(x => x.attr("class") || "");
            let saveSol = Array.from($(".solution div div")).map(x => $(x)).map(x => x.html() || "");
            let saveStateBody = Array.from($("body")).map(x => $(x)).map(x => x.attr("class") || "");
            console.log(saveStates);
            let stateNumber = saveStates.length;
            currentState = stateNumber;

            let s_readState = JSON.stringify(readState);
            let s_gameGrid = JSON.stringify(gameGrid);
            let s_origGameGrid = JSON.stringify(origGameGrid);
            let s_selected = selected;
            let s_selectedTool = selectedTool;
            let s_currX = currX;
            let s_currY = currY;
            let s_antSteps = JSON.stringify(antSteps); // Save antSteps
            let s_gridStates = JSON.stringify(gridStates); // Save gridStates

            let button = $("<button>").text(stateNumber + 1).click(function() {
                $(".netsquare, .ant-child, .tools button, .tool.ant, .leave-button").each((i, x) => $(x).attr("class", saveStateClass[i]));
                $(".solution div div").each((i, x) => $(x).html(saveSol[i]));
                $("body").each((i, x) => $(x).attr("class", saveStateBody[i]));
                currentState = stateNumber;
                selected = s_selected;
                selectedTool = s_selectedTool;
                currX = s_currX;
                currY = s_currY;
                gameGrid = JSON.parse(s_gameGrid);
                origGameGrid = JSON.parse(s_origGameGrid);
                readState = JSON.parse(s_readState);
                antSteps = JSON.parse(s_antSteps); // Restore antSteps
                gridStates = JSON.parse(s_gridStates); // Restore gridStates
            }).addClass("flash").appendTo(".saves");
            setTimeout(() => {
                button.removeClass("flash");
            }, 100);

            saveStates.push(button);
        });
    });
    </script>
    <style>
        :root {
            --sqsize: 77px;
        }
        .square-row {
            height: var(--sqsize);
            margin: 1px;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
        }

        .square {
            margin: 1px;
            width: var(--sqsize);
            height: var(--sqsize);
            float: left;
            font-size: 30px;
            user-select: none;
            text-align: center;
            border: #808080 1px solid;
            transition: background-color 0.2s, color 0.2s;
            box-sizing: border-box;
        }
        .square.numbers, .letters .square {
            margin-top: 16px;
            border-width: 0;
            width: var(--sqsize);
            height: var(--sqsize);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .netsquare {
            height: var(--sqsize);
            width: var(--sqsize);
            font-size: 50px;
            line-height: 85px;
            font-weight: bold;
            cursor: pointer;
            background-color: #13140E;
            position: relative;
        }
        .netsquare.black {
            background-color: #000;
        }
        .netsquare.white {
            background-color: #FFF;
        }
        .netsquare::after {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            content: '';
            width: 0;
            height: 0;
            background: white;
            transition: background 0.2s, top 0.2s, left 0.2s, width 0.2s, height 0.2s;
        }
        .netsquare.dot::after {
            top: 50%;
            left: 50%;
            width: 20%;
            height: 20%;
        }

        .netsquare.white.dot::after {
            background: black;
        }

        .netsquare .ant-child.selected,
        .netsquare.selected {
            border: 4px dashed #00F;
        }

        .othertools .tool {
            margin: 1px;
        }
        .othertools {
            margin-top: 5px;
        }
        .tool {
            width: var(--sqsize);
            height: var(--sqsize);
            float: left;
            font-size: 40px;
            user-select: none;
            text-align: center;
            border: black 1px solid;
            padding-top: 7px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            cursor: pointer;
            box-sizing: border-box;
        }
        .tool, .netsquare {
            background-position: center;
            background-repeat: no-repeat;
            background-size: contain;
        }
        .tool.ant.selected { border: #E23 2px dashed; }
        .tool.rotatetool.selected { border: #33F 2px dashed; }
        .dark .tool:not(.selected) { border-color: #DDD; }

        .rotatetool {
            font-size: 15px;
            padding-top: 2px;
            border-radius: 50%;
        }

        .tools { width: 105px; }
        p.gridlabel { width: 105px; }
        .tools > button, .tools .tool {
            margin: 5px;
        }
        .solved-text {
            color: #0C0;
            transition: color 0.5s;
            user-select: none;
        }
        .invis { color: transparent; }

        .ant.ant1 { background-image: url("img/Game of Ants/ant1.svg"); }
        .ant.ant2 { background-image: url("img/Game of Ants/ant2.svg"); }
        .ant.ant3 { background-image: url("img/Game of Ants/ant3.svg"); }
        .ant.ant4 { background-image: url("img/Game of Ants/ant4.svg"); }
        .ant.ant5 { background-image: url("img/Game of Ants/ant5.svg"); }

        .arot0 { transform: rotate(0); }
        .arot1 { transform: rotate(90deg); }
        .arot2 { transform: rotate(180deg); }
        .arot3 { transform: rotate(270deg); }

        .netsquare .ant-child {
            position: absolute;
            width: 100%;
            height: 100%;
            background-position: center;
            background-repeat: no-repeat;
            background-size: contain;
            transition: width 0.2s, height 0.2s;
        }

        .netsquare .ant-child-0 {
            top: 0;
            left: 0;
        }

        .netsquare .ant-child-1 {
            top: 0;
            right: 0;
        }

        .netsquare .ant-child-2 {
            bottom: 0;
            left: 0;
        }

        .netsquare .ant-child-3 {
            bottom: 0;
            right: 0;
        }

        /* Reduce the size of the child squares when there are multiple ants */
        .netsquare.multiple .ant-child {
            width: 65%;
            height: 65%;
        }

        .tool.reset-grid {
            width: 60px;
            height: 60px;
            padding-top: 9px;
        }
        .square.nopointer {
            cursor: default;
            background: transparent;
            border: none;
        }
        .arrow-spacer {
            width: 35px;
        }
        .square-spacer {
            width: var(--sqsize);
            margin: 1px;
        }

        .gol-grid .square {
            width: 50px;
            height: 50px;
        }
        .gol-grid .square-row {
            height: 50px;
        }


        button {
            font-family: Special Elite;
            background-color: white;
            color: black;
            font-size: 18px;
            border-radius: 5px;
            border: black 3px solid;
            padding: 7px 10px;
            transition: color 1s, background-color 1s;
            margin: 2.5px;
        }
        button:hover {
            background-color: black;
            color: white;
        }
        button.flash {
            color: white;
            background-color: blue;
        }

        .button-spc { height: 29px; }
        .arrows button, .arrow-row button, .square-row button {
            height: 35px;
            width: 35px;
            font-size: 30px;
            padding: 0;
            line-height: 1.3;
            margin: 0;
        }
        button.btn-a {
            transform: rotateZ(90deg);
        }
        button.btn-d {
            transform: rotateZ(-90deg);
        }
        button.btn-w {
            transform: rotateZ(180deg);
        }
        .arrows button.btn-a {
            margin-right: -2.5%;
        }
        .arrows button.btn-d {
            margin-left: -2.5%;
        }

        body.play button.read-solve::before,
        button.read-solve.solve::before {
            content: 'Solve';
        }
        button.read-solve:not(.solve)::before {
            content: 'Read';
        }
        button.show-sol {
            padding: 3px 3px 1px 3px;
        }

        .solution {
            font-size: 15px;
            transition: 0.5s;
        }
        .solution span:not(.str) {
            display: inline-block;
            min-width: 108px;
        }
        body:not(.solution-shown) .solution,
        body:not(.play, .solve) .solution {
            color: transparent;
            font-size: 0;
        }
        .solution > div {
            font-family: 'Roboto Mono';
        }
        .solution > div div svg {
            width: 100px;
            transition: 0.5s;
        }
        body:not(.solution-shown) .solution div div svg,
        body:not(.play, .solve) .solution div div svg {
            width: 0;
        }

        .leave-button.leave {
            background-color: #F00;
        }

        body:not(.play, .solve) .arrows button,
        body:not(.play) button.show-sol,
        body:not(.play, .solve) .reset-grid,
        body:not(.play, .solve) .leave-button,
        :is(body:not(.play), body:not(.solution-shown)) .pause-button,
        body.solution-shown.play .reset-grid,
        body.play button.read-solve {
            user-select: none;
            pointer-events: none;
            background-color: #555;
        }
        button.expert-play.play::before {
            content: 'Generated';
        }
        button.expert-play:not(.play)::before {
            content: 'Manual';
        }
        button.sound.play::before {
            content: 'Sound';
        }
        button.sound:not(.play)::before {
            content: 'Muted';
        }
        button.show-sol.show::before {
            content: 'Solution Shown';
        }
        body:not(.play) button.show-sol::before,
        button.show-sol:not(.show)::before {
            content: 'Solution Hidden';
        }
        :is(body:not(.play), body:not(.solution-shown)) button.pause-button::before,
        button.pause-button.pause::before {
            content: 'Paused';
        }
        button.pause-button:not(.pause)::before {
            content: 'Playing';
        }

        .gol-grid {
            display: block;
            margin: 0 auto;
        }

        .page {
            background-repeat: repeat-y;
            background-position: top;
        }
    </style>
</head>
<body>
    <div class="section">
        <div class="page page-bg-02">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Game of Ants</span>
            </div>
            <div class="page-content">
                <img src="img/Component/Game of Ants.svg" class="diagram">
                <h2>On the Subject of Game of Ants</h2>
                <p class="flavour-text">The Circle rules your life.</p>
                <ul>
                    <li>On this module is a 5×5 grid of cells that can be white or black. Within this grid, there are up to five red ants.</li>
                    <li>This is the initial state of a cellular automaton. To defuse the module, determine the state of the grid after the following steps have been performed.</li>
                </ul>
                <ol>
                    <li>Perform one iteration of <a target="_blank" href="Game of Life Simple.html">Game of Life</a> on the cells of the grid, ignoring the ants.</li>
                    <li>All ants simultaneously move one space forwards, toggling the state of cell it exited from.</li>
                    <li>If two or more ants end up on the same cell, apply these steps in order:
                        <ul>
                            <li>If the ants are facing in different directions, all move another space forwards.</li>
                            <li>If the ants are facing the same direction, all but one ant move another space forwards.</li>
                        </ul>
                    </li>
                    <li>If any ant leaves the grid, skip to step 6.</li>
                    <li>Each ant turns to its left if ends up on a black cell, or to its right if it ends up on a white cell. Repeat steps 2 to 5.</li>
                    <li>Perform another iteration of Game of Life on the resulting grid, once again ignoring the ants.</li>
                </ol>
                <p>To change the state of the grid, select a cell within it.</p>
                <ul>
                    <li>If the blinking button is active, selecting a cell toggles its state.</li>
                    <li>If the ant button is active:
                        <ul>
                            <li>Selecting an empty cell will place an ant on it in the orientation of the button.</li>
                            <li>Selecting a cell with an ant in a different orientation to the button changes the ant’s orientation to match.</li>
                            <li>Selecting a cell with an ant in the same orientation as the button removes the ant from the cell.</li>
                        </ul>
                    </li>
                    <li>Selecting either the blinking or ant button will activate that button and deactivate the other.
                        <ul>
                            <li>Selecting the ant button while it is active rotates it 90&deg; clockwise.</li>
                        </ul>
                    </li>
                    <li>Selecting an arrow marks a location where at least one ant left the grid.<br>Doing so will also activate the ant button and set its orientation to the direction of the arrow.</li>
                </ul>
                <h3>Interactive Controls</h3>
                <ul>
                    <li>
                        In <strong>Read</strong> mode:
                        <ul>
                            <li><strong>Click on a cell</strong> in the grid to toggle its color.</li>
                            <li>Press <strong>Space</strong>/<strong>Enter</strong>/<strong>0</strong> or <strong>1</strong> to quickly enter the Game of Life grid.</li>
                            <li><strong>Right-click on a cell</strong> in the Game of Life grid to mark it as changing.</li>
                            <li><strong>Click an ant tool</strong>, then click on a cell to place an ant in the selected orientation.</li>
                            <li>Using an <strong>ant tool</strong> will remove the ant of that type and replace it where you click.</li>
                            <li>Use the <strong>Rotate tool</strong> or <strong>Ctrl+Click</strong> an ant tool (or a cell containing an ant) to rotate 90° CW. <strong>Shift+Click</strong> to rotate CCW.</li>
                            <li>If a cell contains multiple ants, all ants in the cell will rotate.</li>
                        </ul>
                    </li>
                    <li>
                        In <strong>Solve</strong> mode:
                        <ul>
                            <li><strong>Select an occupied cell</strong> to toggle it and use the <strong>arrow keys</strong> or <strong>WASD</strong> to move the selected ant in the corresponding direction.</li>
                            <li>If a cell contains multiple ants, the first ant in reading order will be moved.</li>
                            <li><strong>Right-click</strong> a cell to select it without toggling.</li>
                            <li>The <strong>Reset</strong> button (↻) will restore the grid and ants to their initial state when switching into <strong>Solve</strong> mode.</li>
                            <li><strong>Click a bordering arrow button</strong> to mark locations where ants left the grid.</li>
                        </ul>
                    </li>
                    <li>
                        In <strong>Generated</strong> mode:
                        <ul>
                            <li>Press the <strong>Manual</strong> button to switch to <strong>Generated</strong> mode.</li>
                            <li>Have fun solving the generated puzzle!</li>
                            <li>Press the <strong>Solution Hidden</strong> button to show the step-by-step solution.</li>
                            <li>Press the <strong>Playing</strong> button to pause or resume the animation of the solution.</li>
                            <li>The puzzle is solved when all cells are the right color, all ants are in the right places and orientations (ant number doesn’t matter), and the location where ant(s) left the grid are marked.</li>
                        </ul>
                    </li>
                    <li>The sound effects can be muted.</li>
                    <li>The <strong>Reset Saves</strong> button clears all the saved states.</li>
                    <li>The <strong>Reset All</strong> button resets the entire interactive.</li>
                </ul>
            </div>
            <div class="page-footer relative-footer">Page 1 of 2</div>
        </div>
        <div class="page page-bg-03 page2">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Game of Ants</span>
            </div>
            <div class="page-content">
                <div class="hstack top left">
                    <div class="vstack">
                        <p><strong>Game of Life</strong></p>
                        <button class="clear-dots">Clear Dots</button>
                    </div>
                    <div class="grid gol-grid vstack left"></div>
                </div>
                <div class="hstack wrap">
                    <div class="vstack tools alignc">
                        <p class="gridlabel"><strong>Ant Grid</strong></p>
                        <h3 class="solved-text invis centered">Solved!</h3>
                        <div class="hstack arrows alignc">
                            <button class="btn-a">▼</button>
                            <div class="vstack alignc">
                                <button class="btn-w">▼</button>
                                <div class="button-spc"></div>
                                <button class="btn-s">▼</button>
                            </div>
                            <button class="btn-d">▼</button>
                        </div>
                        <div class="tool reset-grid">↻</div>
                    </div>
                    <div class="grid ant-grid vstack left"></div>
                </div>
                <div style="height: 5mm"></div>
                <div class="saves hstack wrap left">
                    <button class="save">Save</button>
                </div>
                <div class="hstack left" style="margin-top: 5mm">
                    <button class="reset-saves">Reset Saves</button>
                    <button class="reset-all">Reset All</button>
                    <div style="width: 8mm"></div>
                </div>
                <div style="height: 5mm"></div>
                <div class="solution hstack left top wrap gap2">
                    <div class="vstack alignc">
                        <span>Life phase yields</span>
                        <div class="life-phase"></div>
                    </div>
                    <div class="vstack alignc">
                        <span>Ant travel</span>
                        <div class="ant-travel"></div>
                    </div>
                    <div class="vstack alignc">
                        <span>Ant phase yields</span>
                        <div class="ant-phase"></div>
                    </div>
                    <div class="vstack alignc">
                        <span>Final state</span>
                        <div class="final-state"></div>
                    </div>
                </div>
            </div>
            <div class="page-footer relative-footer">Page 2 of 2</div>
        </div>
    </div>
</body>
</html>