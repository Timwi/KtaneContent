<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <title>Decay — Keep Talking and Nobody Explodes Module</title>
    <link rel="stylesheet" type="text/css" href="css/font.css">
    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/main.css">
    <script src="js/ktane-utils.js"></script>
    <style>
        .nodes {
            width: 7em;
            float: right;
            margin-left: .5em;
            margin-bottom: .5em;
        }

        @media screen and (min-width: 900px), print {
            .nodes {
                width: 13em;
                margin-left: 1em;
                margin-bottom: 1em;
            }
        }

    </style>
</head>
<body>
    <div class="section">
        <div class="page page-bg-01">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Decay</span>
            </div>
            <div class="page-content">
                <img src="img/Component/Decay.svg" class="diagram">
                <h2>On the Subject of Decay</h2>
                <p class="flavour-text">Everything falls apart...</p>
                <p>The module displays 3 pressable symbols. In order to solve the module, press the symbols in the correct order. Any confusing terminology will be explained at the end of the manual.</p>
                <h3>Step 1: Over-Complicated Prime Factorisation</h3>
                <p class="flavour-text">...the numbers...</p>
                <h4>Step 1.1: Decrypting the display</h4>
                <p>The module displays 3 encrypted symbols. To decrypt each symbol individually, interpret the vertical bars as binary, where a vertical connected to the base is a 1 and a vertical disconnected from the base is a 0. Then add 2<sup>k</sup>-1 to this value, where k is the amount of vertical bars on the character. Interpret the three values as base-15 and convert it in its entirety to decimal. This number will be called n.</p>
                <h4>Step 1.2: Constructing the tree</h4>
                <p>Construct a tree consisting of nodes and branches. To construct the tree start with a node with [V<sub>p</sub>=0; V<sub>r</sub>=n]. For each unique prime factor P of V<sub>r</sub>, create a child node with [V<sub>p</sub>=P; V<sub>r</sub>=(V<sub>r,parent</sub>/P)+1]. Order the children in each node from lowest to highest V<sub>p</sub>. This function should be applied to each node with V<sub>r</sub> not being prime. This set of nodes will be called T</p>
            </div>
            <div class="page-footer relative-footer">Page 1 of 5</div>
        </div>
        <div class="page page-bg-02">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Decay</span>
            </div>
            <div class="page-content">
                <h3>Step 2: Neural Network Bit Cascade</h3>
                <p class="flavour-text">...the module...</p>
                <h4>Step 2.1: Obtaining the binary</h4>
                <p>Before any other symbol has been pressed, the middle symbol can be pressed freely. Pressing this symbol will play a sequence of seven notes. This must be converted to a 7-digit sequence of binary. For each note evaluate the following: If the next note is higher than this one, return a 1, otherwise return a 0. For the last note, "the next note" refers to the first note. This set will be called B<sub>i</sub>. Create an empty set called B<sub>f</sub>. Then start with k being 1 and execute the following process: Take the first k digits of the B<sub>i</sub> (repeating B<sub>i</sub> where necessary), reverse it, and append it to B<sub>f</sub>. Change k to k+1 and repeat. This process should be repeated until you have the necessary amount of binary for upcoming steps. You can always generate more if needed. Any time a bit is requested from B<sub>f</sub>, take the first bit that has not been used already.</p>
                <h4>Step 2.2: Assigning the branches</h4>
                <p>Starting from the base node, go to each child in order. Then from this child, go to its children in order and repeat until you hit a node that has no children. Set [b<sub>parent</sub>=B<sub>f,requested</sub>]. If a node has all b<sub>child</sub> assigned, set [b<sub>parent</sub>=Σ(b<sub>child</sub>)%2]. Continue this process until all branches b are assigned.</p>
                <h4>Step 2.3: Backpropagating</h4>
                <p>Start at the base node and set [V<sub>b</sub>=1]. Then go to its children and set [V<sub>b</sub>=V<sub>b,parent</sub>⊻b<sub>parent</sub>]. Go down the entire tree using this process.</p>
            </div>
            <div class="page-footer relative-footer">Page 2 of 5</div>
        </div>
        <div class="page page-bg-03">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Decay</span>
            </div>
            <div class="page-content">
                <h3>Step 3: Quantum Logic</h3>
                <p class="flavour-text">...and eventually...</p>
                <h4>Step 3.1: Obtaining the initial number sequence</h4>
                <p>Create a sequence S with [S<sub>1</sub>=Σ(V<sub>p</sub>); S<sub>2</sub>=Σ(V<sub>p</sub>*V<sub>b</sub>)]. While S<sub>last</sub> is not 0, append [S<sub>second-last</sub>⨬S<sub>last</sub>].</p>
                <h4>Step 3.2: Obtaining the fractions</h4>
                <p>Convert n to base b, where b=Length(S), and interpret every digit as an entry of a sequence S2. If S2 has an odd length, extend the sequence by prepending it with a 0. Then for each k set [S2<sub>k</sub>=S<sub>S2<sub>k</sub>+1</sub>]. Group these numbers in pairs and turn them into fractions as low/high. 0/0 should be turned into 1/2. The set of fractions will be called F.</p>
                <h4>Step 3.3: Making the truth table</h4>
                <p>Before you can apply logic you must make a truth table. For this truth table request 2<sup>Length(F)</sup> bits from B<sub>f</sub>. Each bit will refer to a unique combination of 1's and 0's with a length equal to Length(F). The binary configurations should be ordered from low to high when interpreted as a number and then be connected to the requested bit. Call this truth table TT.</p>
                <h4>Step 3.4: Applying the quantum logic</h4>
                <p>Start with f=0. For each k where TT<sub>k,truth</sub>=1, apply the following: For each p, if TT<sub>k,p</sub>=0, temporarily set [F<sub>p</sub>=1-F<sub>p</sub>]. Then set [f=f+Π(F)] and change the temporarily changed values back. f should be kept as a fraction at all times.</p>
            </div>
            <div class="page-footer relative-footer">Page 3 of 5</div>
        </div>
        <div class="page page-bg-04">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Decay</span>
            </div>
            <div class="page-content">
                <h3>Step 4: Submission</h3>
                <p class="flavour-text">...your sanity.</p>
                <h4>Step 4.1: Obtaining the submission sequence</h4>
                <p>Create an empty sequence S3. Add ⌊f⌋ to S3 and then set [f=1/(f%1)]. Repeat until the numerator is 0.</p>
                <h4>Step 4.2: Submitting the answer</h4>
                <p>To submit S3, convert each value to binary. Enter the digits in these numbers from most to least significant using the left symbol for 0 and the right symbol for 1. The middle symbol is used to enter the current entry of the sequence. Pressing the middle symbol twice consecutively will submit the inputted sequence.</p>
            </div>
            <div class="page-footer relative-footer">Page 4 of 5</div>
        </div>
        <div class="page page-bg-04">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">Decay</span>
            </div>
            <div class="page-content">
                <h3>Terminology</h3>
                <h4>Symbols</h4>
                <ul>
                    <li>Σ(k): returns the sum of all k</li>
                    <li>Π(k): returns the product of all k</li>
                    <li>a%b: a modulo b; divides a by b and returns the remainder</li>
                    <li>a⨬b: a reductive-modulo b; repeatedly subtracts b from a and then 1 from b, until a is less than b or b is 0. If b is 0, returns 0, otherwise returns a</li>
                    <li>⌊k⌋: floor(k); returns k rounded down to the nearest integer</li>
                    <li>a⊻b: a xor b; returns 1 if either input but not both are 1, otherwise returns 0</li>
                    <li>a<sub>b</sub>: b of a; used when a is a set and a specific item is needed. Returns the item requested by b</li>
                </ul>
                <h4>Words and methods</h4>
                <img src="img/Decay/node.svg" class="nodes">
                <ul>
                    <li>Base conversion (b->10): To convert from base b to base 10, start with an answer of 0, then for each digit in order in the number, multiply your answer by b and add the digit to it.</li>
                    <li>Base conversion (10->b): To convert from base 10 to base b, start with an empty set. Take the number modulo b and prepend it to the set. Then divide the number by b and round down. Repeat until the number has been reduced to 0.</li>
                    <li>Decimal: base 10</li>
                    <li>Binary: Base 2; a number base system only including 0 and 1</li>
                    <li>Bit: A single binary character, being either 0 or 1.</li>
                    <li>Prime: A number that is only divisible by 1 and itself. 1 is not prime.</li>
                    <li>Prime factors: The prime numbers a number is divisible by. If it is divisible by a power of that prime, include the prime multiple times.</li>
                    <li>Node: See the diagram to the right; Each node has a V<sub>p</sub>, the prime value; a V<sub>r</sub>, the remainder value; and a V<sub>b</sub>, the binary value. Every node except for the base node has a parent, which is the node it is connected to one layer back. Some nodes have children. If a node has another node as the parent, it is the child of that node.</li>
                    <li>Branch: The connection between 2 nodes; Each branch has a value b, the branch binary value. This will be referred to from either the child or the parent it is connecting and will be labeled oppositely.</li>
                </ul>
            </div>
            <div class="page-footer relative-footer">Page 5 of 5</div>
        </div>
    </div>
</body>
</html>