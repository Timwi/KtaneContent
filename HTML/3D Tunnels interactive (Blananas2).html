<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="initial-scale=1">
    <title>3D Tunnels — Keep Talking and Nobody Explodes Module</title>
    <link rel="stylesheet" type="text/css" href="css/font.css">
    <link rel="stylesheet" type="text/css" href="css/normalize.css">
    <link rel="stylesheet" type="text/css" href="css/main.css">
    <link rel="stylesheet" type="text/css" href="css/Modules/3D Tunnels.css">
    <script src="js/ktane-utils.js"></script>
    <script src="js/ffo/fontfaceobserver.js"></script>
    <style>
        #controls {
            float: left;
            clear: left;
            width: 6.3cm;
            margin-bottom: 1cm;
        }

        canvas { width: 600px; }
    </style>
</head>
<body>
    <div class="section">
        <div class="page page-bg-03">
            <div class="page-header">
                <span class="page-header-doc-title">Keep Talking and Nobody Explodes Mod</span>
                <span class="page-header-section-title">3D Tunnels</span>
            </div>
            <div class="page-content">
                <img src="img/Component/3D Tunnels.svg" class="diagram">
                <h2>On the Subject of Rotatable 3D Tunnels</h2>
                <p class="flavour-text">Let’s take this to <span style="font-family: 'TM';">another</span> dimension.</p>
                <div id="controls">
                    <div><button id="inp-Q">⟲</button><button id="inp-W">↑</button><button id="inp-E">⟳</button></div>
                    <div><button id="inp-A">←</button><button id="inp-S">↓</button><button id="inp-D">→</button></div>
                </div>
                <canvas id="canvas-tunnels" width="600" height="600" tabindex="0" class="invertible"></canvas>
            </div>
            <div class="page-footer relative-footer">Page 1 of 1</div>
        </div>
    </div>
    <script>
const canvas = document.getElementById("canvas-tunnels");
const fr = 24;
let interval;
let animating = false;
let chars = "abcdefghijklmnopqrstuvwxyz.";
let clock = 0;

let points = [];
for (p = 0; p < 27; p++) {
    points.push([p%3, (p/3|0)%3, p/9|0]);
}

document.addEventListener("keydown", (e) => { processKey(e); });

let font = new FontFaceObserver('TM');
Promise.resolve(font.load()).then(() => {
    draw();
})

function draw() { //draw a frame
    if (canvas.getContext) {
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 5;
        ctx.textAlign = "center";
        ctx.font = "25pt TM";
        ctx.fillStyle = "#000";
        if (!animating) {
            for (j = 0; j < 9; j++) {
                let q = j/3|0;
                let r = j % 3; 
                ctx.beginPath();
                ctx.moveTo(conv(q, r, 0).x, conv(q, r, 0).y);
                ctx.lineTo(conv(q, r, 2).x, conv(q, r, 2).y);
                ctx.stroke();
                ctx.closePath();
                ctx.beginPath();
                ctx.moveTo(conv(q, 0, r).x, conv(q, 0, r).y);
                ctx.lineTo(conv(q, 2, r).x, conv(q, 2, r).y);
                ctx.stroke();
                ctx.closePath();
                ctx.beginPath();
                ctx.moveTo(conv(0, q, r).x, conv(0, q, r).y);
                ctx.lineTo(conv(2, q, r).x, conv(2, q, r).y);
                ctx.stroke();
                ctx.closePath();
            }
        } else {
            for (j = 0; j < 9; j++) {
                let q = j/3|0;
                let r = j % 3; 
                ctx.beginPath();
                ctx.moveTo(conv(...points[j*3]).x, conv(...points[j*3]).y);
                ctx.lineTo(conv(...points[j*3 + 2]).x, conv(...points[j*3 + 2]).y);
                ctx.stroke();
                ctx.closePath();
                ctx.beginPath();
                ctx.moveTo(conv(...points[r+q*9]).x, conv(...points[r+q*9]).y);
                ctx.lineTo(conv(...points[r+q*9 + 6]).x, conv(...points[r+q*9 + 6]).y);
                ctx.stroke();
                ctx.closePath();
                ctx.beginPath();
                ctx.moveTo(conv(...points[j]).x, conv(...points[j]).y);
                ctx.lineTo(conv(...points[j+18]).x, conv(...points[j+18]).y);
                ctx.stroke();
                ctx.closePath();
            }
        }
        for (ch = 0; ch < 27; ch++) {
            ctx.fillText(chars[ch], conv(...points[ch]).x, conv(...points[ch]).y + 14, 36);
        }
    }
}

function conv(tx, ty, tz) {
    return { x: 30+220*tx+50*tz, y: 130+220*ty-50*tz };
}

function processKey(ev) {
    let key = ev.key;
    let special = ev.altKey || ev.ctrlKey || ev.shiftKey;
    if (!["Q","W","E","A","S","D"].includes(key.toUpperCase()) || special) {
        return;
    }
    doRotation(ev.key.toUpperCase());
}

function doRotation(k) {
    if (animating) { return; }
    animating = true;
    const ms = 200/fr;
    const un = 1/fr;
    let shallowPoints = [...points];
    let shallowChars = [...chars];
    let rot;
    clock = 0;
    interval = setInterval(() => {
        clock++;
        switch (k.toUpperCase()) {
            case "Q": rot = [6,3,0,7,4,1,8,5,2,15,12,9,16,13,10,17,14,11,24,21,18,25,22,19,26,23,20]; break;
            case "W": rot = [18,19,20,9,10,11,0,1,2,21,22,23,12,13,14,3,4,5,24,25,26,15,16,17,6,7,8]; break;
            case "E": rot = [2,5,8,1,4,7,0,3,6,11,14,17,10,13,16,9,12,15,20,23,26,19,22,25,18,21,24]; break;
            case "A": rot = [18,9,0,21,12,3,24,15,6,19,10,1,22,13,4,25,16,7,20,11,2,23,14,5,26,17,8]; break;
            case "S": rot = [6,7,8,15,16,17,24,25,26,3,4,5,12,13,14,21,22,23,0,1,2,9,10,11,18,19,20]; break;
            case "D": rot = [2,11,20,5,14,23,8,17,26,1,10,19,4,13,22,7,16,25,0,9,18,3,12,21,6,15,24]; break;
            default: break;
        }
        for (p = 0; p < 27; p++) {
            points[p] = [lerp(un*clock, shallowPoints[p][0], shallowPoints[rot[p]][0]), lerp(un*clock, shallowPoints[p][1], shallowPoints[rot[p]][1]), lerp(un*clock, shallowPoints[p][2], shallowPoints[rot[p]][2])];
        }
        if (clock >= fr) {
            clearInterval(interval);
            interval = null;
            animating = false;
            let newchars = Array(27);
            for (h = 0; h < 27; h++) {
                newchars[rot[h]] = shallowChars[h];
            }
            chars = newchars.join("");
            points = shallowPoints;
        }
        draw();
    }, ms);
}


function lerp(t, a, b) {
    return a * (1 - t) + b * t;
}

for (let b = 0; b < 6; b++) {
    let d = "QWEASD";
    document.getElementById('inp-' + d[b]).onclick = function () { doRotation(d[b]); };
}
</script>
</body>
</html>